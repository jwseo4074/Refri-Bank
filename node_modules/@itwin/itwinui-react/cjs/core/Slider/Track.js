"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Track = void 0;
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Bentley Systems, Incorporated. All rights reserved.
 * See LICENSE.md in the project root for license terms and full copyright notice.
 *--------------------------------------------------------------------------------------------*/
var react_1 = __importDefault(require("react"));
function shouldDisplaySegment(segmentIndex, mode) {
    if ('odd-segments' === mode && 0 === (segmentIndex + 1) % 2) {
        return true;
    }
    else if ('even-segments' === mode && 0 === segmentIndex % 2) {
        return true;
    }
    return false;
}
function generateSegments(values, min, max) {
    var segments = [];
    var newValues = __spreadArray([], values, true);
    newValues.sort(function (a, b) { return a - b; });
    if (0 === newValues.length ||
        newValues[0] < min ||
        newValues[newValues.length - 1] > max ||
        min === max) {
        return [];
    }
    var lastValue = min;
    for (var i = 0; i < newValues.length; i++) {
        segments.push({ left: lastValue, right: newValues[i] });
        lastValue = newValues[i];
    }
    segments.push({ left: lastValue, right: max });
    return segments;
}
/**
 * Track displays color segments above Rail. Which, if any, segments that are
 * colorized is based on `trackDisplayMode`.
 */
var Track = function (props) {
    var trackDisplayMode = props.trackDisplayMode, sliderMin = props.sliderMin, sliderMax = props.sliderMax, values = props.values;
    var _a = react_1.default.useState(function () {
        return generateSegments(values, sliderMin, sliderMax);
    }), segments = _a[0], setSegments = _a[1];
    react_1.default.useEffect(function () {
        setSegments(generateSegments(values, sliderMin, sliderMax));
    }, [values, sliderMin, sliderMax]);
    return (react_1.default.createElement(react_1.default.Fragment, null, 'none' !== trackDisplayMode &&
        segments.map(function (segment, index) {
            var leftPercent = segment.left >= sliderMin && sliderMax !== sliderMin
                ? (100.0 * (segment.left - sliderMin)) / (sliderMax - sliderMin)
                : 0;
            var rightPercent = segment.right >= sliderMin && sliderMax !== sliderMin
                ? 100.0 -
                    (100.0 * (segment.right - sliderMin)) / (sliderMax - sliderMin)
                : 100;
            return (react_1.default.createElement(react_1.default.Fragment, { key: index }, shouldDisplaySegment(index, trackDisplayMode) ? (react_1.default.createElement("div", { className: 'iui-slider-track', style: { left: "".concat(leftPercent, "%"), right: "".concat(rightPercent, "%") } })) : null));
        })));
};
exports.Track = Track;
