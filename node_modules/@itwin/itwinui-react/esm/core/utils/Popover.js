/*---------------------------------------------------------------------------------------------
 * Copyright (c) Bentley Systems, Incorporated. All rights reserved.
 * See LICENSE.md in the project root for license terms and full copyright notice.
 *--------------------------------------------------------------------------------------------*/
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
import React from 'react';
import Tippy from '@tippyjs/react';
import { useMergedRefs } from './hooks/useMergedRefs';
/**
 * Wrapper around [tippy.js](https://atomiks.github.io/tippyjs)
 * with pre-configured props and plugins (e.g. lazy mounting, focus, etc).
 * @private
 */
export var Popover = React.forwardRef(function (props, ref) {
    var _a = React.useState(false), mounted = _a[0], setMounted = _a[1];
    var tippyRef = React.useRef(null);
    var refs = useMergedRefs(tippyRef, ref);
    // Plugin to allow lazy mounting. See https://github.com/atomiks/tippyjs-react#lazy-mounting
    var lazyLoad = {
        fn: function () { return ({
            onShow: function () { return setMounted(true); },
            onHidden: function () { return setMounted(false); },
        }); },
    };
    // Plugin to remove tabindex from tippy, to prevent focus ring from unintentionally showing.
    var removeTabIndex = {
        fn: function () { return ({
            onCreate: function (instance) {
                var _a;
                (_a = instance.popper.firstElementChild) === null || _a === void 0 ? void 0 : _a.removeAttribute('tabindex');
            },
        }); },
    };
    var computedProps = __assign(__assign({ allowHTML: true, animation: false, appendTo: 'parent', arrow: false, duration: 0, interactive: true, popperOptions: {
            strategy: 'fixed',
            modifiers: [{ name: 'flip' }],
        }, role: undefined, offset: [0, 0] }, props), { plugins: __spreadArray([
            lazyLoad,
            removeTabIndex,
            hideOnEscOrTab
        ], (props.plugins || [])) });
    if (props.render) {
        var render_1 = props.render;
        computedProps.render = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return (mounted ? render_1.apply(void 0, args) : '');
        };
    }
    else {
        computedProps.content = mounted ? props.content : '';
    }
    return React.createElement(Tippy, __assign({}, computedProps, { ref: refs }));
});
/**
 * Plugin to hide Popover when either Esc key is pressed,
 * or when the content inside is not tabbable and Tab key is pressed.
 */
export var hideOnEscOrTab = {
    fn: function (instance) {
        /** @returns true if none of the children are tabbable */
        var shouldHideOnTab = function () {
            var descendents = Array.from(instance.popper.querySelectorAll('*'));
            return !descendents.some(function (el) { return (el === null || el === void 0 ? void 0 : el.tabIndex) >= 0; });
        };
        var onKeyDown = function (event) {
            switch (event.key) {
                case 'Escape':
                    instance.hide();
                    break;
                case 'Tab':
                    if (shouldHideOnTab()) {
                        event.shiftKey && event.preventDefault(); // focus popover target on Shift+Tab
                        instance.hide();
                    }
                    break;
            }
        };
        return {
            onShow: function () {
                instance.popper.addEventListener('keydown', onKeyDown);
            },
            onHide: function () {
                instance.popper.removeEventListener('keydown', onKeyDown);
            },
        };
    },
};
export default Popover;
