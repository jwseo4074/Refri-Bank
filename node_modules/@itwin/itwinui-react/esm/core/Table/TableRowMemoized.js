var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Bentley Systems, Incorporated. All rights reserved.
 * See LICENSE.md in the project root for license terms and full copyright notice.
 *--------------------------------------------------------------------------------------------*/
import React from 'react';
import cx from 'classnames';
import { useIntersection, useMergedRefs, WithCSSTransition } from '../utils';
import { TableCell } from './TableCell';
/**
 * Memoization is needed to avoid unnecessary re-renders of all rows when additional data is added when lazy-loading.
 * Using `isLast` here instead of passing data length to avoid re-renders of all rows when more data is added. Now only the last row re-renders.
 * Although state is not used it is needed for `React.memo` to check state that changes row state e.g. selection.
 * When adding new features check whether it changes state that affects row. If it does then add equality check to `React.memo`.
 */
export var TableRow = function (props) {
    var row = props.row, rowProps = props.rowProps, isLast = props.isLast, onRowInViewport = props.onRowInViewport, onBottomReached = props.onBottomReached, intersectionMargin = props.intersectionMargin, onClick = props.onClick, subComponent = props.subComponent, isDisabled = props.isDisabled, tableHasSubRows = props.tableHasSubRows, tableInstance = props.tableInstance, expanderCell = props.expanderCell;
    var onIntersect = React.useCallback(function () {
        var _a, _b;
        (_a = onRowInViewport.current) === null || _a === void 0 ? void 0 : _a.call(onRowInViewport, row.original);
        isLast && ((_b = onBottomReached.current) === null || _b === void 0 ? void 0 : _b.call(onBottomReached));
    }, [isLast, onBottomReached, onRowInViewport, row.original]);
    var rowRef = useIntersection(onIntersect, {
        rootMargin: "".concat(intersectionMargin, "px"),
    });
    var userRowProps = rowProps === null || rowProps === void 0 ? void 0 : rowProps(row);
    var mergedProps = __assign(__assign(__assign({}, row.getRowProps({ style: { flex: "0 0 auto", minWidth: '100%' } })), userRowProps), {
        className: cx('iui-row', {
            'iui-selected': row.isSelected,
            'iui-row-expanded': row.isExpanded && subComponent,
            'iui-disabled': isDisabled,
        }, userRowProps === null || userRowProps === void 0 ? void 0 : userRowProps.className),
    });
    var refs = useMergedRefs(rowRef, mergedProps.ref);
    return (React.createElement(React.Fragment, null,
        React.createElement("div", __assign({}, mergedProps, { ref: refs, onClick: function (event) {
                var _a;
                (_a = mergedProps === null || mergedProps === void 0 ? void 0 : mergedProps.onClick) === null || _a === void 0 ? void 0 : _a.call(mergedProps, event);
                onClick === null || onClick === void 0 ? void 0 : onClick(event, row);
            } }), row.cells.map(function (cell, index) {
            return (React.createElement(TableCell, { key: cell.getCellProps().key, cell: cell, cellIndex: index, isDisabled: isDisabled, tableHasSubRows: tableHasSubRows, tableInstance: tableInstance, expanderCell: expanderCell }));
        })),
        subComponent && (React.createElement(WithCSSTransition, { in: row.isExpanded },
            React.createElement("div", { className: cx('iui-row', 'iui-expanded-content', {
                    'iui-disabled': isDisabled,
                }) }, subComponent(row))))));
};
var hasAnySelectedSubRow = function (row, selectedRowIds) {
    if (selectedRowIds === null || selectedRowIds === void 0 ? void 0 : selectedRowIds[row.id]) {
        return true;
    }
    return row.subRows.some(function (subRow) {
        return hasAnySelectedSubRow(subRow, selectedRowIds);
    });
};
export var TableRowMemoized = React.memo(TableRow, function (prevProp, nextProp) {
    var _a, _b, _c, _d, _e, _f, _g;
    return prevProp.isLast === nextProp.isLast &&
        ((_a = prevProp.state.hiddenColumns) === null || _a === void 0 ? void 0 : _a.length) ===
            ((_b = nextProp.state.hiddenColumns) === null || _b === void 0 ? void 0 : _b.length) &&
        !!((_c = prevProp.state.hiddenColumns) === null || _c === void 0 ? void 0 : _c.every(function (column, index) { var _a; return ((_a = nextProp.state.hiddenColumns) === null || _a === void 0 ? void 0 : _a[index]) === column; })) &&
        prevProp.onRowInViewport === nextProp.onRowInViewport &&
        prevProp.onBottomReached === nextProp.onBottomReached &&
        prevProp.onClick === nextProp.onClick &&
        prevProp.row.original === nextProp.row.original &&
        ((_d = prevProp.state.selectedRowIds) === null || _d === void 0 ? void 0 : _d[prevProp.row.id]) ===
            ((_e = nextProp.state.selectedRowIds) === null || _e === void 0 ? void 0 : _e[nextProp.row.id]) &&
        // Check if sub-rows selection has changed and whether to show indeterminate state or not
        prevProp.row.subRows.some(function (subRow) {
            return hasAnySelectedSubRow(subRow, prevProp.state.selectedRowIds);
        }) ===
            nextProp.row.subRows.some(function (subRow) {
                return hasAnySelectedSubRow(subRow, nextProp.state.selectedRowIds);
            }) &&
        ((_f = prevProp.state.expanded) === null || _f === void 0 ? void 0 : _f[prevProp.row.id]) ===
            ((_g = nextProp.state.expanded) === null || _g === void 0 ? void 0 : _g[nextProp.row.id]) &&
        prevProp.subComponent === nextProp.subComponent &&
        prevProp.row.cells.every(function (cell, index) { return nextProp.row.cells[index].column === cell.column; }) &&
        prevProp.isDisabled === nextProp.isDisabled &&
        prevProp.rowProps === nextProp.rowProps &&
        prevProp.expanderCell === nextProp.expanderCell &&
        prevProp.tableHasSubRows === nextProp.tableHasSubRows &&
        prevProp.state.columnOrder === nextProp.state.columnOrder &&
        !nextProp.state.columnResizing.isResizingColumn &&
        prevProp.state.isTableResizing === nextProp.state.isTableResizing;
});
