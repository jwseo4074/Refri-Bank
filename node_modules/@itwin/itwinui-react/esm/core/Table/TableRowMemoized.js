var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Bentley Systems, Incorporated. All rights reserved.
 * See LICENSE.md in the project root for license terms and full copyright notice.
 *--------------------------------------------------------------------------------------------*/
import React from 'react';
import cx from 'classnames';
import { useIntersection } from '../utils/hooks/useIntersection';
import { getCellStyle } from './utils';
import { CSSTransition } from 'react-transition-group';
import { useMergedRefs } from '../utils/hooks/useMergedRefs';
/**
 * Memoization is needed to avoid unnecessary re-renders of all rows when additional data is added when lazy-loading.
 * Using `isLast` here instead of passing data length to avoid re-renders of all rows when more data is added. Now only the last row re-renders.
 * Although state is not used it is needed for `React.memo` to check state that changes row state e.g. selection.
 * When adding new features check whether it changes state that affects row. If it does then add equality check to `React.memo`.
 */
var TableRow = function (props) {
    var row = props.row, rowProps = props.rowProps, isLast = props.isLast, onRowInViewport = props.onRowInViewport, onBottomReached = props.onBottomReached, intersectionMargin = props.intersectionMargin, onClick = props.onClick, subComponent = props.subComponent, isDisabled = props.isDisabled;
    var onIntersect = React.useCallback(function () {
        var _a, _b;
        (_a = onRowInViewport.current) === null || _a === void 0 ? void 0 : _a.call(onRowInViewport, row.original);
        isLast && ((_b = onBottomReached.current) === null || _b === void 0 ? void 0 : _b.call(onBottomReached));
    }, [isLast, onBottomReached, onRowInViewport, row.original]);
    var rowRef = useIntersection(onIntersect, {
        rootMargin: intersectionMargin + "px",
    });
    var expandedHeight = React.useRef(0);
    var userRowProps = rowProps === null || rowProps === void 0 ? void 0 : rowProps(row);
    var mergedProps = __assign(__assign(__assign({}, row.getRowProps()), userRowProps), {
        className: cx('iui-row', {
            'iui-selected': row.isSelected,
            'iui-row-expanded': row.isExpanded && subComponent,
            'iui-disabled': isDisabled,
        }, userRowProps === null || userRowProps === void 0 ? void 0 : userRowProps.className),
    });
    var refs = useMergedRefs(rowRef, mergedProps.ref);
    return (React.createElement(React.Fragment, null,
        React.createElement("div", __assign({}, mergedProps, { ref: refs, onClick: function (event) {
                var _a;
                (_a = mergedProps === null || mergedProps === void 0 ? void 0 : mergedProps.onClick) === null || _a === void 0 ? void 0 : _a.call(mergedProps, event);
                onClick === null || onClick === void 0 ? void 0 : onClick(event, row);
            } }), row.cells.map(function (cell) {
            var cellProps = cell.getCellProps({
                className: cx('iui-cell', cell.column.cellClassName),
                style: getCellStyle(cell.column),
            });
            return (React.createElement("div", __assign({}, cellProps, { key: cellProps.key }), cell.render('Cell')));
        })),
        subComponent && (React.createElement(CSSTransition, { in: row.isExpanded, timeout: 200, unmountOnExit: true, onEnter: function (node) { return (node.style.height = "0px"); }, onEntering: function (node) {
                return (node.style.height = expandedHeight.current + "px");
            }, onEntered: function (node) { return (node.style.height = 'auto'); }, onExit: function (node) { return (node.style.height = expandedHeight.current + "px"); }, onExiting: function (node) { return (node.style.height = "0px"); }, classNames: 'iui' }, React.createElement("div", { className: 'iui-row iui-expanded-content', ref: function (ref) {
                if (ref) {
                    expandedHeight.current = ref.offsetHeight;
                }
            } }, subComponent(row))))));
};
export var TableRowMemoized = React.memo(TableRow, function (prevProp, nextProp) {
    var _a, _b, _c, _d;
    return prevProp.isLast === nextProp.isLast &&
        prevProp.onRowInViewport === nextProp.onRowInViewport &&
        prevProp.onBottomReached === nextProp.onBottomReached &&
        prevProp.onClick === nextProp.onClick &&
        prevProp.row.original === nextProp.row.original &&
        ((_a = prevProp.state.selectedRowIds) === null || _a === void 0 ? void 0 : _a[prevProp.row.id]) ===
            ((_b = nextProp.state.selectedRowIds) === null || _b === void 0 ? void 0 : _b[nextProp.row.id]) &&
        ((_c = prevProp.state.expanded) === null || _c === void 0 ? void 0 : _c[prevProp.row.id]) ===
            ((_d = nextProp.state.expanded) === null || _d === void 0 ? void 0 : _d[nextProp.row.id]) &&
        prevProp.subComponent === nextProp.subComponent &&
        prevProp.row.cells.every(function (cell, index) { return nextProp.row.cells[index].column === cell.column; }) &&
        prevProp.isDisabled === nextProp.isDisabled &&
        prevProp.rowProps === nextProp.rowProps;
});
