var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Bentley Systems, Incorporated. All rights reserved.
 * See LICENSE.md in the project root for license terms and full copyright notice.
 *--------------------------------------------------------------------------------------------*/
import React from 'react';
import cx from 'classnames';
import { actions as TableActions, useFlexLayout, useFilters, useRowSelect, useSortBy, useTable, useExpanded, usePagination, useColumnOrder, } from 'react-table';
import { ProgressRadial } from '../ProgressIndicators';
import { useTheme, useResizeObserver } from '../utils';
import '@itwin/itwinui-css/css/table.css';
import SvgSortDown from '@itwin/itwinui-icons-react/cjs/icons/SortDown';
import SvgSortUp from '@itwin/itwinui-icons-react/cjs/icons/SortUp';
import { getCellStyle } from './utils';
import { TableRowMemoized } from './TableRowMemoized';
import { FilterToggle } from './filters';
import { customFilterFunctions } from './filters/customFilterFunctions';
import { useExpanderCell, useSelectionCell, useSubRowFiltering, useSubRowSelection, useResizeColumns, useColumnDragAndDrop, } from './hooks';
import { onExpandHandler, onFilterHandler, onSelectHandler, onSingleSelectHandler, onTableResizeEnd, onTableResizeStart, } from './actionHandlers';
import VirtualScroll from '../utils/components/VirtualScroll';
import { SELECTION_CELL_ID } from './columns';
var singleRowSelectedAction = 'singleRowSelected';
export var tableResizeStartAction = 'tableResizeStart';
var tableResizeEndAction = 'tableResizeEnd';
var flattenColumns = function (columns) {
    var flatColumns = [];
    columns.forEach(function (column) {
        flatColumns.push(column);
        if (column.columns) {
            flatColumns.push.apply(flatColumns, flattenColumns(column.columns));
        }
    });
    return flatColumns;
};
/**
 * Table based on [react-table](https://react-table.tanstack.com/docs/api/overview).
 * @example
 * const columns = React.useMemo(() => [
 *  {
 *    Header: 'Header name',
 *    columns: [
 *      {
 *        id: 'name',
 *        Header: 'Name',
 *        accessor: 'name',
 *        width: 90,
 *      },
 *      {
 *        id: 'description',
 *        Header: 'description',
 *        accessor: 'description',
 *        maxWidth: 200,
 *      },
 *      {
 *        id: 'view',
 *        Header: 'view',
 *        Cell: () => {
 *          return <span onClick={onViewClick}>View</span>
 *        },
 *      },
 *    ],
 *  },
 * ], [onViewClick])
 * const data = [
 *  { name: 'Name1', description: 'Description1' },
 *  { name: 'Name2', description: 'Description2' },
 *  { name: 'Name3', description: 'Description3' },
 * ]
 * <Table
 *   columns={columns}
 *   data={data}
 *   emptyTableContent='No data.'
 *   isLoading={false}
 *   isSortable={true}
 * />
 */
export var Table = function (props) {
    var _a;
    var data = props.data, columns = props.columns, _b = props.isLoading, isLoading = _b === void 0 ? false : _b, emptyTableContent = props.emptyTableContent, className = props.className, style = props.style, id = props.id, _c = props.isSelectable, isSelectable = _c === void 0 ? false : _c, onSelect = props.onSelect, onRowClick = props.onRowClick, _d = props.selectionMode, selectionMode = _d === void 0 ? 'multi' : _d, _e = props.isSortable, isSortable = _e === void 0 ? false : _e, onSort = props.onSort, stateReducer = props.stateReducer, onBottomReached = props.onBottomReached, onRowInViewport = props.onRowInViewport, _f = props.intersectionMargin, intersectionMargin = _f === void 0 ? 300 : _f, subComponent = props.subComponent, onExpand = props.onExpand, onFilter = props.onFilter, emptyFilteredTableContent = props.emptyFilteredTableContent, filterFunctions = props.filterTypes, expanderCell = props.expanderCell, isRowDisabled = props.isRowDisabled, rowProps = props.rowProps, _g = props.density, density = _g === void 0 ? 'default' : _g, _h = props.selectSubRows, selectSubRows = _h === void 0 ? true : _h, getSubRows = props.getSubRows, _j = props.selectRowOnClick, selectRowOnClick = _j === void 0 ? true : _j, paginatorRenderer = props.paginatorRenderer, _k = props.pageSize, pageSize = _k === void 0 ? 25 : _k, _l = props.isResizable, isResizable = _l === void 0 ? false : _l, _m = props.styleType, styleType = _m === void 0 ? 'default' : _m, _o = props.enableVirtualization, enableVirtualization = _o === void 0 ? false : _o, _p = props.enableColumnReordering, enableColumnReordering = _p === void 0 ? false : _p, rest = __rest(props, ["data", "columns", "isLoading", "emptyTableContent", "className", "style", "id", "isSelectable", "onSelect", "onRowClick", "selectionMode", "isSortable", "onSort", "stateReducer", "onBottomReached", "onRowInViewport", "intersectionMargin", "subComponent", "onExpand", "onFilter", "emptyFilteredTableContent", "filterTypes", "expanderCell", "isRowDisabled", "rowProps", "density", "selectSubRows", "getSubRows", "selectRowOnClick", "paginatorRenderer", "pageSize", "isResizable", "styleType", "enableVirtualization", "enableColumnReordering"]);
    useTheme();
    var _q = React.useState(), ownerDocument = _q[0], setOwnerDocument = _q[1];
    var defaultColumn = React.useMemo(function () { return ({
        maxWidth: 0,
        minWidth: 0,
        width: 0,
    }); }, []);
    // useRef prevents from rerendering when one of these callbacks changes
    var onBottomReachedRef = React.useRef(onBottomReached);
    var onRowInViewportRef = React.useRef(onRowInViewport);
    React.useEffect(function () {
        onBottomReachedRef.current = onBottomReached;
        onRowInViewportRef.current = onRowInViewport;
    }, [onBottomReached, onRowInViewport]);
    var hasManualSelectionColumn = React.useMemo(function () {
        var flatColumns = flattenColumns(columns);
        return flatColumns.some(function (column) { return column.id === SELECTION_CELL_ID; });
    }, [columns]);
    var tableStateReducer = React.useCallback(function (newState, action, previousState, instance) {
        switch (action.type) {
            case TableActions.toggleSortBy:
                onSort === null || onSort === void 0 ? void 0 : onSort(newState);
                break;
            case TableActions.setFilter:
                onFilterHandler(newState, action, previousState, instance, onFilter);
                break;
            case TableActions.toggleRowExpanded:
            case TableActions.toggleAllRowsExpanded:
                onExpandHandler(newState, instance, onExpand);
                break;
            case singleRowSelectedAction: {
                newState = onSingleSelectHandler(newState, action, instance, onSelect, 
                // If it has manual selection column, then we can't check whether row is disabled
                hasManualSelectionColumn ? undefined : isRowDisabled);
                break;
            }
            case TableActions.toggleRowSelected:
            case TableActions.toggleAllRowsSelected:
            case TableActions.toggleAllPageRowsSelected: {
                onSelectHandler(newState, instance, onSelect, 
                // If it has manual selection column, then we can't check whether row is disabled
                hasManualSelectionColumn ? undefined : isRowDisabled);
                break;
            }
            case tableResizeStartAction: {
                newState = onTableResizeStart(newState);
                break;
            }
            case tableResizeEndAction: {
                newState = onTableResizeEnd(newState, action);
                break;
            }
            default:
                break;
        }
        return stateReducer
            ? stateReducer(newState, action, previousState, instance)
            : newState;
    }, [
        hasManualSelectionColumn,
        isRowDisabled,
        onExpand,
        onFilter,
        onSelect,
        onSort,
        stateReducer,
    ]);
    var filterTypes = React.useMemo(function () { return (__assign(__assign({}, customFilterFunctions), filterFunctions)); }, [filterFunctions]);
    var hasAnySubRows = React.useMemo(function () {
        return data.some(function (item, index) {
            return getSubRows ? getSubRows(item, index) : item.subRows;
        });
    }, [data, getSubRows]);
    var instance = useTable(__assign(__assign({ manualPagination: !paginatorRenderer, paginateExpandedRows: false }, props), { columns: columns, defaultColumn: defaultColumn, disableSortBy: !isSortable, stateReducer: tableStateReducer, filterTypes: filterTypes, selectSubRows: selectSubRows, data: data, getSubRows: getSubRows, initialState: __assign({ pageSize: pageSize }, props.initialState) }), useFlexLayout, useResizeColumns(ownerDocument), useFilters, useSubRowFiltering(hasAnySubRows), useSortBy, useExpanded, usePagination, useRowSelect, useSubRowSelection, useExpanderCell(subComponent, expanderCell, isRowDisabled), useSelectionCell(isSelectable, selectionMode, isRowDisabled), useColumnOrder, useColumnDragAndDrop(enableColumnReordering));
    var getTableProps = instance.getTableProps, rows = instance.rows, headerGroups = instance.headerGroups, getTableBodyProps = instance.getTableBodyProps, prepareRow = instance.prepareRow, state = instance.state, allColumns = instance.allColumns, filteredFlatRows = instance.filteredFlatRows, dispatch = instance.dispatch, page = instance.page, gotoPage = instance.gotoPage, setPageSize = instance.setPageSize, flatHeaders = instance.flatHeaders;
    var ariaDataAttributes = Object.entries(rest).reduce(function (result, _a) {
        var key = _a[0], value = _a[1];
        if (key.startsWith('data-') || key.startsWith('aria-')) {
            result[key] = value;
        }
        return result;
    }, {});
    var areFiltersSet = allColumns.some(function (column) { return column.filterValue != null && column.filterValue !== ''; });
    var onRowClickHandler = React.useCallback(function (event, row) {
        var isDisabled = isRowDisabled === null || isRowDisabled === void 0 ? void 0 : isRowDisabled(row.original);
        if (!isDisabled) {
            onRowClick === null || onRowClick === void 0 ? void 0 : onRowClick(event, row);
        }
        if (isSelectable &&
            !isDisabled &&
            selectRowOnClick &&
            !event.isDefaultPrevented()) {
            if (!row.isSelected && (selectionMode === 'single' || !event.ctrlKey)) {
                dispatch({
                    type: singleRowSelectedAction,
                    id: row.id,
                });
            }
            else {
                row.toggleRowSelected(!row.isSelected);
            }
        }
    }, [
        isRowDisabled,
        isSelectable,
        selectRowOnClick,
        selectionMode,
        dispatch,
        onRowClick,
    ]);
    React.useEffect(function () {
        setPageSize(pageSize);
    }, [pageSize, setPageSize]);
    var paginatorRendererProps = React.useMemo(function () { return ({
        currentPage: state.pageIndex,
        pageSize: state.pageSize,
        totalRowsCount: rows.length,
        size: density !== 'default' ? 'small' : 'default',
        isLoading: isLoading,
        onPageChange: gotoPage,
        onPageSizeChange: setPageSize,
    }); }, [
        density,
        gotoPage,
        isLoading,
        rows.length,
        setPageSize,
        state.pageIndex,
        state.pageSize,
    ]);
    var columnRefs = React.useRef({});
    var previousTableWidth = React.useRef(0);
    var onTableResize = React.useCallback(function (_a) {
        var width = _a.width;
        if (width === previousTableWidth.current) {
            return;
        }
        previousTableWidth.current = width;
        // Update column widths when table was resized
        flatHeaders.forEach(function (header) {
            if (columnRefs.current[header.id]) {
                header.resizeWidth = columnRefs.current[header.id].getBoundingClientRect().width;
            }
        });
        // If no column was resized then leave table resize handling to the flexbox
        if (Object.keys(state.columnResizing.columnWidths).length === 0) {
            return;
        }
        dispatch({ type: tableResizeStartAction });
    }, [dispatch, state.columnResizing.columnWidths, flatHeaders]);
    var resizeRef = useResizeObserver(onTableResize)[0];
    // Flexbox handles columns resize so we take new column widths before browser repaints.
    React.useLayoutEffect(function () {
        if (state.isTableResizing) {
            var newColumnWidths_1 = {};
            flatHeaders.forEach(function (column) {
                if (columnRefs.current[column.id]) {
                    newColumnWidths_1[column.id] = columnRefs.current[column.id].getBoundingClientRect().width;
                }
            });
            dispatch({ type: tableResizeEndAction, columnWidths: newColumnWidths_1 });
        }
    });
    var headerRef = React.useRef(null);
    var bodyRef = React.useRef(null);
    var getPreparedRow = React.useCallback(function (index) {
        var row = page[index];
        prepareRow(row);
        return (React.createElement(TableRowMemoized, { row: row, rowProps: rowProps, isLast: index === page.length - 1, onRowInViewport: onRowInViewportRef, onBottomReached: onBottomReachedRef, intersectionMargin: intersectionMargin, state: state, key: row.getRowProps().key, onClick: onRowClickHandler, subComponent: subComponent, isDisabled: !!(isRowDisabled === null || isRowDisabled === void 0 ? void 0 : isRowDisabled(row.original)), tableHasSubRows: hasAnySubRows, tableInstance: instance, expanderCell: expanderCell }));
    }, [
        page,
        expanderCell,
        hasAnySubRows,
        instance,
        intersectionMargin,
        isRowDisabled,
        onRowClickHandler,
        prepareRow,
        rowProps,
        state,
        subComponent,
    ]);
    var virtualizedItemRenderer = React.useCallback(function (index) { return getPreparedRow(index); }, [getPreparedRow]);
    return (React.createElement(React.Fragment, null,
        React.createElement("div", __assign({ ref: function (element) {
                setOwnerDocument(element === null || element === void 0 ? void 0 : element.ownerDocument);
                if (isResizable) {
                    resizeRef(element);
                }
            }, id: id }, getTableProps({
            className: cx('iui-table', (_a = {}, _a["iui-".concat(density)] = density !== 'default', _a), className),
            style: style,
        }), ariaDataAttributes),
            React.createElement("div", { className: 'iui-table-header', ref: headerRef }, headerGroups.slice(1).map(function (headerGroup) {
                var headerGroupProps = headerGroup.getHeaderGroupProps({
                    className: 'iui-row',
                });
                return (React.createElement("div", __assign({}, headerGroupProps, { key: headerGroupProps.key }), headerGroup.headers.map(function (column, index) {
                    var columnProps = column.getHeaderProps(__assign(__assign({}, column.getSortByToggleProps()), { className: cx('iui-cell', { 'iui-actionable': column.canSort }, { 'iui-sorted': column.isSorted }, column.columnClassName), style: __assign(__assign({}, getCellStyle(column, !!state.isTableResizing)), { flexWrap: 'unset' }) }));
                    return (React.createElement("div", __assign({}, columnProps, column.getDragAndDropProps(), { key: columnProps.key, title: undefined, ref: function (el) {
                            if (el && isResizable) {
                                columnRefs.current[column.id] = el;
                                column.resizeWidth = el.getBoundingClientRect().width;
                            }
                        } }),
                        column.render('Header'),
                        (data.length !== 0 || areFiltersSet) && (React.createElement(FilterToggle, { column: column, ownerDocument: ownerDocument })),
                        data.length !== 0 && column.canSort && (React.createElement("div", { className: 'iui-cell-end-icon' }, column.isSorted && column.isSortedDesc ? (React.createElement(SvgSortDown, { className: 'iui-icon iui-sort', "aria-hidden": true })) : (React.createElement(SvgSortUp, { className: 'iui-icon iui-sort', "aria-hidden": true })))),
                        isResizable &&
                            column.isResizerVisible &&
                            index !== headerGroup.headers.length - 1 && (React.createElement("div", __assign({}, column.getResizerProps(), { className: 'iui-resizer' }),
                            React.createElement("div", { className: 'iui-resizer-bar' }))),
                        enableColumnReordering && !column.disableReordering && (React.createElement("div", { className: 'iui-reorder-bar' }))));
                })));
            })),
            React.createElement("div", __assign({}, getTableBodyProps({
                className: cx('iui-table-body', {
                    'iui-zebra-striping': styleType === 'zebra-rows',
                }),
                style: { outline: 0 },
            }), { ref: bodyRef, onScroll: function () {
                    if (headerRef.current && bodyRef.current) {
                        headerRef.current.scrollLeft = bodyRef.current.scrollLeft;
                    }
                }, tabIndex: -1 }),
                data.length !== 0 && (React.createElement(React.Fragment, null, enableVirtualization ? (React.createElement(VirtualScroll, { itemsLength: page.length, itemRenderer: virtualizedItemRenderer })) : (page.map(function (_, index) { return getPreparedRow(index); })))),
                isLoading && data.length === 0 && (React.createElement("div", { className: 'iui-table-empty' },
                    React.createElement(ProgressRadial, { indeterminate: true }))),
                isLoading && data.length !== 0 && (React.createElement("div", { className: 'iui-row' },
                    React.createElement("div", { className: 'iui-cell', style: { justifyContent: 'center' } },
                        React.createElement(ProgressRadial, { indeterminate: true, size: 'small', style: { float: 'none', marginLeft: 0 } })))),
                !isLoading && data.length === 0 && !areFiltersSet && (React.createElement("div", { className: 'iui-table-empty' },
                    React.createElement("div", null, emptyTableContent))),
                !isLoading &&
                    (data.length === 0 || filteredFlatRows.length === 0) &&
                    areFiltersSet && (React.createElement("div", { className: 'iui-table-empty' },
                    React.createElement("div", null, emptyFilteredTableContent)))), paginatorRenderer === null || paginatorRenderer === void 0 ? void 0 :
            paginatorRenderer(paginatorRendererProps))));
};
export default Table;
