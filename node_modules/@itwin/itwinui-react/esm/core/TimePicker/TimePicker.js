var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Bentley Systems, Incorporated. All rights reserved.
 * See LICENSE.md in the project root for license terms and full copyright notice.
 *--------------------------------------------------------------------------------------------*/
import cx from 'classnames';
import React from 'react';
import { useTheme } from '../utils';
import '@itwin/itwinui-css/css/time-picker.css';
var isSameHour = function (date1, date2, meridiem) {
    var adjustedHours = meridiem
        ? formatHourFrom12(date1.getHours(), meridiem)
        : date1.getHours();
    if (!!meridiem) {
        return !!date2 && adjustedHours % 12 === date2.getHours() % 12;
    }
    return !!date2 && adjustedHours === date2.getHours();
};
var isSameMinute = function (date1, date2) {
    return !!date2 && date1.getMinutes() === date2.getMinutes();
};
var isSameSecond = function (date1, date2) {
    return !!date2 && date1.getSeconds() === date2.getSeconds();
};
var isSameMeridiem = function (meridiem, date) {
    return (!!date && (meridiem === 'AM' ? date.getHours() < 12 : date.getHours() >= 12));
};
var formatHourFrom12 = function (hour, meridiem) {
    var adjustedHour = hour % 12;
    return meridiem === 'PM' ? adjustedHour + 12 : adjustedHour;
};
var setHours = function (hour, date) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), hour, date.getMinutes(), date.getSeconds());
};
/**
 * Time picker component
 * @example
 * <TimePicker date={new Date()} onChange={(e) => console.log('New time value: ' + e)} />
 */
export var TimePicker = function (props) {
    var date = props.date, onChange = props.onChange, _a = props.use12Hours, use12Hours = _a === void 0 ? false : _a, _b = props.precision, precision = _b === void 0 ? 'minutes' : _b, _c = props.hourStep, hourStep = _c === void 0 ? 1 : _c, _d = props.minuteStep, minuteStep = _d === void 0 ? 1 : _d, _e = props.secondStep, secondStep = _e === void 0 ? 1 : _e, _f = props.setFocusHour, setFocusHour = _f === void 0 ? false : _f, _g = props.hourRenderer, hourRenderer = _g === void 0 ? function (date) {
        return date.getHours().toLocaleString(undefined, { minimumIntegerDigits: 2 });
    } : _g, _h = props.minuteRenderer, minuteRenderer = _h === void 0 ? function (date) {
        return date.getMinutes().toLocaleString(undefined, { minimumIntegerDigits: 2 });
    } : _h, _j = props.secondRenderer, secondRenderer = _j === void 0 ? function (date) {
        return date.getSeconds().toLocaleString(undefined, { minimumIntegerDigits: 2 });
    } : _j, _k = props.meridiemRenderer, meridiemRenderer = _k === void 0 ? function (meridiem) { return meridiem; } : _k, className = props.className, rest = __rest(props, ["date", "onChange", "use12Hours", "precision", "hourStep", "minuteStep", "secondStep", "setFocusHour", "hourRenderer", "minuteRenderer", "secondRenderer", "meridiemRenderer", "className"]);
    useTheme();
    var _l = React.useState(date), selectedTime = _l[0], setSelectedTime = _l[1];
    var _m = React.useState(selectedTime !== null && selectedTime !== void 0 ? selectedTime : new Date()), focusedTime = _m[0], setFocusedTime = _m[1];
    var _o = React.useState(use12Hours ? ((focusedTime === null || focusedTime === void 0 ? void 0 : focusedTime.getHours()) > 11 ? 'PM' : 'AM') : undefined), meridiem = _o[0], setMeridiem = _o[1];
    React.useEffect(function () {
        setFocusedTime(date !== null && date !== void 0 ? date : new Date());
        setSelectedTime(date);
    }, [date]);
    var onHourClick = function (date) {
        var adjustedHour = use12Hours
            ? formatHourFrom12(date.getHours(), meridiem)
            : date.getHours();
        var adjustedSelectedTime = setHours(adjustedHour, selectedTime !== null && selectedTime !== void 0 ? selectedTime : new Date());
        updateCurrentTime(adjustedSelectedTime);
    };
    var onMeridiemClick = function (value) {
        var adjustedSelectedTime = selectedTime !== null && selectedTime !== void 0 ? selectedTime : new Date();
        var currentHours = adjustedSelectedTime.getHours();
        setMeridiem(value);
        if (value === 'AM' && currentHours > 11) {
            adjustedSelectedTime = setHours(currentHours - 12, adjustedSelectedTime);
        }
        if (value === 'PM' && currentHours <= 12) {
            adjustedSelectedTime = setHours(currentHours + 12, adjustedSelectedTime);
        }
        updateCurrentTime(adjustedSelectedTime);
    };
    var updateCurrentTime = function (time) {
        var adjustedTime = time;
        // Nullify other values, according to precision
        if (precision === 'hours') {
            adjustedTime = new Date(time.getFullYear(), time.getMonth(), time.getDate(), time.getHours(), 0, 0);
        }
        if (precision === 'minutes') {
            adjustedTime = new Date(time.getFullYear(), time.getMonth(), time.getDate(), time.getHours(), time.getMinutes(), 0);
        }
        setFocusedTime(adjustedTime);
        setSelectedTime(adjustedTime);
        onChange === null || onChange === void 0 ? void 0 : onChange(adjustedTime);
    };
    var onHourFocus = function (date) {
        var adjustedHour = use12Hours
            ? formatHourFrom12(date.getHours(), meridiem)
            : date.getHours();
        setFocusedTime(setHours(adjustedHour, focusedTime));
    };
    var onMeridiemFocus = function (value) {
        var adjustedSelectedTime = selectedTime !== null && selectedTime !== void 0 ? selectedTime : new Date();
        var currentHours = adjustedSelectedTime.getHours();
        if (value === 'AM' && currentHours > 11) {
            setMeridiem(value);
            adjustedSelectedTime = setHours(currentHours - 12, adjustedSelectedTime);
        }
        if (value === 'PM' && currentHours <= 12) {
            setMeridiem(value);
            adjustedSelectedTime = setHours(currentHours + 12, adjustedSelectedTime);
        }
        setFocusedTime(adjustedSelectedTime);
    };
    var generateDataList = function (size, value, step) {
        var data = [];
        for (var i = 0; i < size; ++i) {
            if (i % step === 0) {
                data.push(value(i));
            }
        }
        return data;
    };
    var hours = React.useMemo(function () {
        var time = selectedTime !== null && selectedTime !== void 0 ? selectedTime : new Date();
        return generateDataList(use12Hours ? 12 : 24, function (i) {
            return new Date(time.getFullYear(), time.getMonth(), time.getDate(), use12Hours && i === 0 ? 12 : i, time.getMinutes(), time.getSeconds());
        }, hourStep);
    }, [hourStep, selectedTime, use12Hours]);
    var minutes = React.useMemo(function () {
        var time = selectedTime !== null && selectedTime !== void 0 ? selectedTime : new Date();
        return generateDataList(60, function (i) {
            return new Date(time.getFullYear(), time.getMonth(), time.getDate(), time.getHours(), i, time.getSeconds());
        }, minuteStep);
    }, [minuteStep, selectedTime]);
    var seconds = React.useMemo(function () {
        var time = selectedTime !== null && selectedTime !== void 0 ? selectedTime : new Date();
        return generateDataList(60, function (i) {
            return new Date(time.getFullYear(), time.getMonth(), time.getDate(), time.getHours(), time.getMinutes(), i);
        }, secondStep);
    }, [secondStep, selectedTime]);
    return (React.createElement("div", __assign({ className: cx('iui-time-picker', className) }, rest),
        React.createElement(TimePickerColumn, { data: hours, isSameFocused: function (val) {
                return isSameHour(val, focusedTime, use12Hours ? meridiem : undefined);
            }, isSameSelected: function (val) {
                return isSameHour(val, selectedTime, use12Hours ? meridiem : undefined);
            }, onFocusChange: onHourFocus, onSelectChange: onHourClick, setFocus: setFocusHour, valueRenderer: hourRenderer }),
        precision != 'hours' && (React.createElement(TimePickerColumn, { data: minutes, isSameFocused: function (val) { return isSameMinute(val, focusedTime); }, isSameSelected: function (val) { return isSameMinute(val, selectedTime); }, onFocusChange: function (date) { return setFocusedTime(date); }, onSelectChange: function (date) { return updateCurrentTime(date); }, valueRenderer: minuteRenderer })),
        precision == 'seconds' && (React.createElement(TimePickerColumn, { data: seconds, isSameFocused: function (val) { return isSameSecond(val, focusedTime); }, isSameSelected: function (val) { return isSameSecond(val, selectedTime); }, onFocusChange: function (date) { return setFocusedTime(date); }, onSelectChange: function (date) { return updateCurrentTime(date); }, valueRenderer: secondRenderer })),
        use12Hours && (React.createElement(TimePickerColumn, { data: ['AM', 'PM'], isSameFocused: function (val) { return isSameMeridiem(val, focusedTime); }, isSameSelected: function (val) { return isSameMeridiem(val, selectedTime); }, onFocusChange: function (date) { return onMeridiemFocus(date); }, onSelectChange: function (value) { return onMeridiemClick(value); }, valueRenderer: meridiemRenderer, className: 'iui-period' }))));
};
var TimePickerColumn = function (props) {
    var data = props.data, onFocusChange = props.onFocusChange, onSelectChange = props.onSelectChange, isSameFocused = props.isSameFocused, isSameSelected = props.isSameSelected, _a = props.setFocus, setFocus = _a === void 0 ? false : _a, valueRenderer = props.valueRenderer, _b = props.className, className = _b === void 0 ? 'iui-time' : _b;
    var needFocus = React.useRef(setFocus);
    // Used to focus row only when changed (keyboard navigation)
    // e.g. without this on every rerender it would be focused
    React.useEffect(function () {
        if (needFocus.current) {
            needFocus.current = false;
        }
    });
    var scrollIntoView = function (ref, isSame) {
        isSame && (ref === null || ref === void 0 ? void 0 : ref.scrollIntoView({ block: 'nearest', inline: 'nearest' }));
    };
    var handleTimeKeyDown = function (event, maxValue, onFocus, onSelect, currentValue) {
        switch (event.key) {
            case 'ArrowDown':
                if (currentValue + 1 > maxValue) {
                    break;
                }
                onFocus(currentValue + 1);
                needFocus.current = true;
                event.preventDefault();
                break;
            case 'ArrowUp':
                if (currentValue - 1 < 0) {
                    break;
                }
                onFocus(currentValue - 1);
                needFocus.current = true;
                event.preventDefault();
                break;
            case 'Enter':
            case ' ':
            case 'Spacebar':
                onSelect(currentValue);
                event.preventDefault();
                break;
        }
    };
    return (React.createElement("div", { className: className },
        React.createElement("ol", null, data.map(function (value, index) {
            var isSameFocus = isSameFocused(value);
            return (React.createElement("li", { onKeyDown: function (event) {
                    handleTimeKeyDown(event, data.length - 1, function (index) { return onFocusChange(data[index]); }, function (index) { return onSelectChange(data[index]); }, index);
                }, className: cx({
                    'iui-selected': isSameSelected(value),
                }), key: index, tabIndex: isSameFocus ? 0 : undefined, ref: function (ref) {
                    scrollIntoView(ref, isSameFocus);
                    needFocus.current && isSameFocus && (ref === null || ref === void 0 ? void 0 : ref.focus());
                }, onClick: function () {
                    onSelectChange(value);
                } }, valueRenderer(value)));
        }))));
};
export default TimePicker;
