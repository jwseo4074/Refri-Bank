var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Bentley Systems, Incorporated. All rights reserved.
 * See LICENSE.md in the project root for license terms and full copyright notice.
 *--------------------------------------------------------------------------------------------*/
import React from 'react';
import ReactDOM from 'react-dom';
import { getContainer } from '../utils';
import { ToastWrapper } from './ToastWrapper';
var TOASTS_CONTAINER_ID = 'iui-toasts-container';
var Toaster = /** @class */ (function () {
    function Toaster() {
        var _this = this;
        this.toasts = [];
        this.lastId = 0;
        this.settings = {
            order: 'descending',
            placement: 'top',
        };
        this.toastsRef = React.createRef();
        this.isInitialized = false;
        // Create container on demand.
        // Cannot do it in constructor, because SSG/SSR apps would fail.
        this.asyncInit = new Promise(function (resolve) {
            if (_this.isInitialized) {
                resolve();
                return;
            }
            var container = getContainer(TOASTS_CONTAINER_ID);
            if (!container) {
                // should never happen
                resolve();
                return;
            }
            _this.isInitialized = true;
            ReactDOM.render(React.createElement(ToastWrapper, { ref: _this.toastsRef }), container);
            resolve();
        });
    }
    /**
     * Set global Toaster settings for toasts order and placement.
     * Settings will be applied to new toasts on the page.
     */
    Toaster.prototype.setSettings = function (newSettings) {
        var _this = this;
        var _a, _b, _c;
        (_a = newSettings.placement) !== null && _a !== void 0 ? _a : (newSettings.placement = this.settings.placement);
        (_b = newSettings.order) !== null && _b !== void 0 ? _b : (newSettings.order = ((_c = newSettings.placement) === null || _c === void 0 ? void 0 : _c.startsWith('bottom'))
            ? 'ascending'
            : 'descending');
        this.settings = newSettings;
        this.asyncInit.then(function () {
            var _a, _b;
            (_a = _this.toastsRef.current) === null || _a === void 0 ? void 0 : _a.setPlacement((_b = _this.settings.placement) !== null && _b !== void 0 ? _b : 'top');
        });
    };
    Toaster.prototype.positive = function (content, options) {
        return this.createToast(content, 'positive', options);
    };
    Toaster.prototype.informational = function (content, options) {
        return this.createToast(content, 'informational', options);
    };
    Toaster.prototype.negative = function (content, options) {
        return this.createToast(content, 'negative', options);
    };
    Toaster.prototype.warning = function (content, options) {
        return this.createToast(content, 'warning', options);
    };
    Toaster.prototype.createToast = function (content, category, options) {
        var _this = this;
        ++this.lastId;
        var currentId = this.lastId;
        this.toasts = __spreadArray(__spreadArray(__spreadArray([], (this.settings.order === 'ascending' ? this.toasts : []), true), [
            __assign(__assign({}, options), { content: content, category: category, onRemove: function () {
                    var _a;
                    _this.removeToast(currentId);
                    (_a = options === null || options === void 0 ? void 0 : options.onRemove) === null || _a === void 0 ? void 0 : _a.call(options);
                }, id: currentId, isVisible: true })
        ], false), (this.settings.order === 'descending' ? this.toasts : []), true);
        this.updateView();
        return { close: function () { return _this.closeToast(currentId); } };
    };
    Toaster.prototype.removeToast = function (id) {
        this.toasts = this.toasts.filter(function (toast) { return toast.id !== id; });
        this.updateView();
    };
    Toaster.prototype.updateView = function () {
        var _this = this;
        this.asyncInit.then(function () {
            var _a;
            (_a = _this.toastsRef.current) === null || _a === void 0 ? void 0 : _a.setToasts(_this.toasts);
        });
    };
    Toaster.prototype.closeToast = function (toastId) {
        this.toasts = this.toasts.map(function (toast) {
            return __assign(__assign({}, toast), { isVisible: toast.id !== toastId });
        });
        this.updateView();
    };
    Toaster.prototype.closeAll = function () {
        this.toasts = this.toasts.map(function (toast) {
            return __assign(__assign({}, toast), { isVisible: false });
        });
        this.updateView();
    };
    return Toaster;
}());
export default Toaster;
