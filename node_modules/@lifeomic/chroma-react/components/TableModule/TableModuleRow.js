"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableModuleRow = void 0;
var clsx_1 = __importDefault(require("clsx"));
var React = __importStar(require("react"));
var TableModule_1 = require("./TableModule");
var getTestProps_1 = require("../../testUtils/getTestProps");
var TableModule_2 = require("./TableModule");
var TableModuleCell_1 = require("./TableModuleCell");
var TableModuleActions_1 = require("./TableModuleActions");
var IconButton_1 = require("../IconButton");
var chromicons_1 = require("@lifeomic/chromicons");
var Tooltip_1 = require("../Tooltip");
var TableModuleRow = React.memo(function (_a) {
    var onRowClick = _a.onRowClick, rowRole = _a.rowRole, row = _a.row, maxCellWidth = _a.maxCellWidth, headingsLength = _a.headingsLength, cells = _a.cells, rowActions = _a.rowActions, rowClickLabel = _a.rowClickLabel;
    var classes = (0, TableModule_1.useStyles)({});
    var handleRowClick = React.useCallback(function (e) {
        var _a, _b, _c, _d, _e, _f, _g;
        /*
          :'(

          It appears we have to add this ugly check due to the way our Checkbox works.
          It's likely a thing with framer-motion, as the native <input type="checkbox" does not
          run into this problem.

          Anyway, without this check, the order of events is:
          1) Row click handler
          2) Checkbox handler

          Whereas what we *need* is the checkbox handler to run *first*, and then we would
          stopPropagation() from within the checkbox onClick event.  Since we can't do that,
          for whatever reason with our Checkbox component, we are doing this check.
        */
        if (((_a = e.target) === null || _a === void 0 ? void 0 : _a.tagName) === 'path' &&
            ((_c = (_b = e.target) === null || _b === void 0 ? void 0 : _b.parentElement) === null || _c === void 0 ? void 0 : _c.tagName) === 'svg' &&
            ((_f = (_e = (_d = e.target) === null || _d === void 0 ? void 0 : _d.parentElement) === null || _e === void 0 ? void 0 : _e.parentElement) === null || _f === void 0 ? void 0 : _f.tagName) === 'LABEL') {
            return;
        }
        (_g = e === null || e === void 0 ? void 0 : e.currentTarget) === null || _g === void 0 ? void 0 : _g.blur();
        onRowClick === null || onRowClick === void 0 ? void 0 : onRowClick(row);
    }, [onRowClick, row]);
    var rowContents = React.useMemo(function () {
        return cells === null || cells === void 0 ? void 0 : cells.map(function (cell, colIndex) {
            var cellContent = cell.content
                ? cell.content(row)
                : cell.valuePath && row[cell.valuePath];
            return (React.createElement(TableModuleCell_1.TableModuleCell, { key: "column-".concat(colIndex), maxCellWidth: maxCellWidth, isLastCellInRow: headingsLength > 1 && colIndex === headingsLength - 1, cell: cell }, cellContent));
        });
    }, [cells, headingsLength, maxCellWidth, row]);
    var maybeRowActions = React.useMemo(function () { return rowActions === null || rowActions === void 0 ? void 0 : rowActions(row); }, [
        row,
        rowActions,
    ]);
    return (React.createElement("tr", __assign({ className: (0, clsx_1.default)(classes.tableRow, classes.tableDataRow, onRowClick && classes.clickable), onClick: handleRowClick, role: rowRole || 'row', tabIndex: 0 }, (0, getTestProps_1.getTestProps)(TableModule_2.testIds.bodyRow)),
        rowContents,
        (onRowClick || rowActions) && (React.createElement("td", { className: (0, clsx_1.default)(classes.tableRowCell, classes.tableRowActionCell, classes.sticky), role: "cell" }, (Boolean(maybeRowActions) || onRowClick) && (React.createElement(TableModuleActions_1.TableModuleActions, { className: classes.tableModuleActions, tabIndex: 0 },
            maybeRowActions,
            onRowClick && (React.createElement(Tooltip_1.Tooltip, { title: rowClickLabel || 'View Details' },
                React.createElement(IconButton_1.IconButton, { "aria-label": rowClickLabel || 'View Details', icon: chromicons_1.ChevronRight, color: "inverse", onClick: function (e) {
                        e.stopPropagation();
                        e.currentTarget.blur();
                        onRowClick === null || onRowClick === void 0 ? void 0 : onRowClick(row);
                    } })))))))));
});
exports.TableModuleRow = TableModuleRow;
TableModuleRow.displayName = 'TableModuleRow';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFibGVNb2R1bGVSb3cuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9UYWJsZU1vZHVsZS9UYWJsZU1vZHVsZVJvdy50c3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDhDQUF3QjtBQUN4QiwyQ0FBK0I7QUFDL0IsNkNBQTBDO0FBQzFDLDZEQUE0RDtBQUU1RCw2Q0FBMEQ7QUFDMUQscURBQW9EO0FBQ3BELDJEQUEwRDtBQUMxRCw0Q0FBMkM7QUFDM0MsbURBQW9EO0FBQ3BELHNDQUFxQztBQWtCckMsSUFBTSxjQUFjLEdBQWtDLEtBQUssQ0FBQyxJQUFJLENBQzlELFVBQUMsRUFTQTtRQVJDLFVBQVUsZ0JBQUEsRUFDVixPQUFPLGFBQUEsRUFDUCxHQUFHLFNBQUEsRUFDSCxZQUFZLGtCQUFBLEVBQ1osY0FBYyxvQkFBQSxFQUNkLEtBQUssV0FBQSxFQUNMLFVBQVUsZ0JBQUEsRUFDVixhQUFhLG1CQUFBO0lBRWIsSUFBTSxPQUFPLEdBQUcsSUFBQSx1QkFBUyxFQUFDLEVBQUUsQ0FBQyxDQUFDO0lBRTlCLElBQU0sY0FBYyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQ3RDLFVBQUMsQ0FBQzs7UUFDQTs7Ozs7Ozs7Ozs7Ozs7VUFjRTtRQUNGLElBQ0UsQ0FBQSxNQUFBLENBQUMsQ0FBQyxNQUFNLDBDQUFFLE9BQU8sTUFBSyxNQUFNO1lBQzVCLENBQUEsTUFBQSxNQUFBLENBQUMsQ0FBQyxNQUFNLDBDQUFFLGFBQWEsMENBQUUsT0FBTyxNQUFLLEtBQUs7WUFDMUMsQ0FBQSxNQUFBLE1BQUEsTUFBQSxDQUFDLENBQUMsTUFBTSwwQ0FBRSxhQUFhLDBDQUFFLGFBQWEsMENBQUUsT0FBTyxNQUFLLE9BQU8sRUFDM0Q7WUFDQSxPQUFPO1NBQ1I7UUFFRCxNQUFBLENBQUMsYUFBRCxDQUFDLHVCQUFELENBQUMsQ0FBRSxhQUFhLDBD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bHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlU3R5bGVzIH0gZnJvbSAnLi9UYWJsZU1vZHVsZSc7XG5pbXBvcnQgeyBnZXRUZXN0UHJvcHMgfSBmcm9tICcuLi8uLi90ZXN0VXRpbHMvZ2V0VGVzdFByb3BzJztcbmltcG9ydCB7IFRhYmxlQ2VsbCB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgVGFibGVNb2R1bGVQcm9wcywgdGVzdElkcyB9IGZyb20gJy4vVGFibGVNb2R1bGUnO1xuaW1wb3J0IHsgVGFibGVNb2R1bGVDZWxsIH0gZnJvbSAnLi9UYWJsZU1vZHVsZUNlbGwnO1xuaW1wb3J0IHsgVGFibGVNb2R1bGVBY3Rpb25zIH0gZnJvbSAnLi9UYWJsZU1vZHVsZUFjdGlvbnMnO1xuaW1wb3J0IHsgSWNvbkJ1dHRvbiB9IGZyb20gJy4uL0ljb25CdXR0b24nO1xuaW1wb3J0IHsgQ2hldnJvblJpZ2h0IH0gZnJvbSAnQGxpZmVvbWljL2Nocm9taWNvbnMnO1xuaW1wb3J0IHsgVG9vbHRpcCB9IGZyb20gJy4uL1Rvb2x0aXAnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlTW9kdWxlUm93UHJvcHNcbiAgZXh0ZW5kcyBSZWFjdC5EZXRhaWxlZEhUTUxQcm9wczxcbiAgICBSZWFjdC5IVE1MQXR0cmlidXRlczxIVE1MVGFibGVFbGVtZW50PixcbiAgICBIVE1MVGFibGVFbGVtZW50XG4gID4ge1xuICBkYXRhPzogYW55O1xuICBvblJvd0NsaWNrPzogKHJvdzogYW55KSA9PiB2b2lkO1xuICByb3dSb2xlPzogJ2xpbmsnO1xuICBtYXhDZWxsV2lkdGg/OiAxIHwgMjtcbiAgcm93OiBhbnk7XG4gIGhlYWRpbmdzTGVuZ3RoOiBudW1iZXI7XG4gIGNlbGxzOiBBcnJheTxUYWJsZUNlbGw+O1xuICByb3dBY3Rpb25zPzogVGFibGVNb2R1bGVQcm9wc1sncm93QWN0aW9ucyddO1xuICByb3dDbGlja0xhYmVsPzogVGFibGVNb2R1bGVQcm9wc1sncm93Q2xpY2tMYWJlbCddO1xufVxuXG5jb25zdCBUYWJsZU1vZHVsZVJvdzogUmVhY3QuRkM8VGFibGVNb2R1bGVSb3dQcm9wcz4gPSBSZWFjdC5tZW1vKFxuICAoe1xuICAgIG9uUm93Q2xpY2ssXG4gICAgcm93Um9sZSxcbiAgICByb3csXG4gICAgbWF4Q2VsbFdpZHRoLFxuICAgIGhlYWRpbmdzTGVuZ3RoLFxuICAgIGNlbGxzLFxuICAgIHJvd0FjdGlvbnMsXG4gICAgcm93Q2xpY2tMYWJlbCxcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGNsYXNzZXMgPSB1c2VTdHlsZXMoe30pO1xuXG4gICAgY29uc3QgaGFuZGxlUm93Q2xpY2sgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIC8qXG4gICAgICAgICAgOicoXG5cbiAgICAgICAgICBJdCBhcHBlYXJzIHdlIGhhdmUgdG8gYWRkIHRoaXMgdWdseSBjaGVjayBkdWUgdG8gdGhlIHdheSBvdXIgQ2hlY2tib3ggd29ya3MuXG4gICAgICAgICAgSXQncyBsaWtlbHkgYSB0aGluZyB3aXRoIGZyYW1lci1tb3Rpb24sIGFzIHRoZSBuYXRpdmUgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGRvZXMgbm90XG4gICAgICAgICAgcnVuIGludG8gdGhpcyBwcm9ibGVtLlxuXG4gICAgICAgICAgQW55d2F5LCB3aXRob3V0IHRoaXMgY2hlY2ssIHRoZSBvcmRlciBvZiBldmVudHMgaXM6XG4gICAgICAgICAgMSkgUm93IGNsaWNrIGhhbmRsZXJcbiAgICAgICAgICAyKSBDaGVja2JveCBoYW5kbGVyXG5cbiAgICAgICAgICBXaGVyZWFzIHdoYXQgd2UgKm5lZWQqIGlzIHRoZSBjaGVja2JveCBoYW5kbGVyIHRvIHJ1biAqZmlyc3QqLCBhbmQgdGhlbiB3ZSB3b3VsZFxuICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbigpIGZyb20gd2l0aGluIHRoZSBjaGVja2JveCBvbkNsaWNrIGV2ZW50LiAgU2luY2Ugd2UgY2FuJ3QgZG8gdGhhdCxcbiAgICAgICAgICBmb3Igd2hhdGV2ZXIgcmVhc29uIHdpdGggb3VyIENoZWNrYm94IGNvbXBvbmVudCwgd2UgYXJlIGRvaW5nIHRoaXMgY2hlY2suXG4gICAgICAgICovXG4gICAgICAgIGlmIChcbiAgICAgICAgICBlLnRhcmdldD8udGFnTmFtZSA9PT0gJ3BhdGgnICYmXG4gICAgICAgICAgZS50YXJnZXQ/LnBhcmVudEVsZW1lbnQ/LnRhZ05hbWUgPT09ICdzdmcnICYmXG4gICAgICAgICAgZS50YXJnZXQ/LnBhcmVudEVsZW1lbnQ/LnBhcmVudEVsZW1lbnQ/LnRhZ05hbWUgPT09ICdMQUJFTCdcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZT8uY3VycmVudFRhcmdldD8uYmx1cigpO1xuXG4gICAgICAgIG9uUm93Q2xpY2s/Lihyb3cpO1xuICAgICAgfSxcbiAgICAgIFtvblJvd0NsaWNrLCByb3ddXG4gICAgKTtcblxuICAgIGNvbnN0IHJvd0NvbnRlbnRzID0gUmVhY3QudXNlTWVtbyhcbiAgICAgICgpID0+XG4gICAgICAgIGNlbGxzPy5tYXAoKGNlbGwsIGNvbEluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgY2VsbENvbnRlbnQgPSBjZWxsLmNvbnRlbnRcbiAgICAgICAgICAgID8gY2VsbC5jb250ZW50KHJvdylcbiAgICAgICAgICAgIDogY2VsbC52YWx1ZVBhdGggJiYgcm93W2NlbGwudmFsdWVQYXRoXTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPFRhYmxlTW9kdWxlQ2VsbFxuICAgICAgICAgICAgICBrZXk9e2Bjb2x1bW4tJHtjb2xJbmRleH1gfVxuICAgICAgICAgICAgICBtYXhDZWxsV2lkdGg9e21heENlbGxXaWR0aH1cbiAgICAgICAgICAgICAgaXNMYXN0Q2VsbEluUm93PXtcbiAgICAgICAgICAgICAgICBoZWFkaW5nc0xlbmd0aCA+IDEgJiYgY29sSW5kZXggPT09IGhlYWRpbmdzTGVuZ3RoIC0gMVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNlbGw9e2NlbGx9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtjZWxsQ29udGVudH1cbiAgICAgICAgICAgIDwvVGFibGVNb2R1bGVDZWxsPlxuICAgICAgICAgICk7XG4gICAgICAgIH0pLFxuICAgICAgW2NlbGxzLCBoZWFkaW5nc0xlbmd0aCwgbWF4Q2VsbFdpZHRoLCByb3ddXG4gICAgKTtcblxuICAgIGNvbnN0IG1heWJlUm93QWN0aW9ucyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gcm93QWN0aW9ucz8uKHJvdyksIFtcbiAgICAgIHJvdyxcbiAgICAgIHJvd0FjdGlvbnMsXG4gICAgXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPHRyXG4gICAgICAgIGNsYXNzTmFtZT17Y2xzeChcbiAgICAgICAgICBjbGFzc2VzLnRhYmxlUm93LFxuICAgICAgICAgIGNsYXNzZXMudGFibGVEYXRhUm93LFxuICAgICAgICAgIG9uUm93Q2xpY2sgJiYgY2xhc3Nlcy5jbGlja2FibGVcbiAgICAgICAgKX1cbiAgICAgICAgb25DbGljaz17aGFuZGxlUm93Q2xpY2t9XG4gICAgICAgIHJvbGU9e3Jvd1JvbGUgfHwgJ3Jvdyd9XG4gICAgICAgIHRhYkluZGV4PXswfVxuICAgICAgICB7Li4uZ2V0VGVzdFByb3BzKHRlc3RJZHMuYm9keVJvdyl9XG4gICAgICA+XG4gICAgICAgIHtyb3dDb250ZW50c31cbiAgICAgICAgeyhvblJvd0NsaWNrIHx8IHJvd0FjdGlvbnMpICYmIChcbiAgICAgICAgICA8dGRcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xzeChcbiAgICAgICAgICAgICAgY2xhc3Nlcy50YWJsZVJvd0NlbGwsXG4gICAgICAgICAgICAgIGNsYXNzZXMudGFibGVSb3dBY3Rpb25DZWxsLFxuICAgICAgICAgICAgICBjbGFzc2VzLnN0aWNreVxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIHJvbGU9XCJjZWxsXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICB7KEJvb2xlYW4obWF5YmVSb3dBY3Rpb25zKSB8fCBvblJvd0NsaWNrKSAmJiAoXG4gICAgICAgICAgICAgIDxUYWJsZU1vZHVsZUFjdGlvbnNcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzZXMudGFibGVNb2R1bGVBY3Rpb25zfVxuICAgICAgICAgICAgICAgIHRhYkluZGV4PXswfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge21heWJlUm93QWN0aW9uc31cbiAgICAgICAgICAgICAgICB7b25Sb3dDbGljayAmJiAoXG4gICAgICAgICAgICAgICAgICA8VG9vbHRpcCB0aXRsZT17cm93Q2xpY2tMYWJlbCB8fCAnVmlldyBEZXRhaWxzJ30+XG4gICAgICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD17cm93Q2xpY2tMYWJlbCB8fCAnVmlldyBEZXRhaWxzJ31cbiAgICAgICAgICAgICAgICAgICAgICBpY29uPXtDaGV2cm9uUmlnaHR9XG4gICAgICAgICAgICAgICAgICAgICAgY29sb3I9XCJpbnZlcnNlXCJcbiAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuY3VycmVudFRhcmdldC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblJvd0NsaWNrPy4ocm93KTtcbiAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgPC9Ub29sdGlwPlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIDwvVGFibGVNb2R1bGVBY3Rpb25zPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L3RkPlxuICAgICAgICApfVxuICAgICAgPC90cj5cbiAgICApO1xuICB9XG4pO1xuXG5UYWJsZU1vZHVsZVJvdy5kaXNwbGF5TmFtZSA9ICdUYWJsZU1vZHVsZVJvdyc7XG5cbmV4cG9ydCB7IFRhYmxlTW9kdWxlUm93IH07XG4iXX0=