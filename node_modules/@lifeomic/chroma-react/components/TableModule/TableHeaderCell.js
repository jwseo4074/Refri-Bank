"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var clsx_1 = __importDefault(require("clsx"));
var React = __importStar(require("react"));
var chromicons_1 = require("@lifeomic/chromicons");
var index_1 = require("../../styles/index");
exports.TableHeaderCellStylesKey = 'ChromaTableHeaderCell';
exports.useStyles = index_1.makeStyles(function (theme) { return ({
    root: {
        transition: 'color 0.25s ease',
        background: theme.palette.common.white,
        borderCollapse: 'collapse',
        borderSpacing: 0,
        fontSize: theme.typography.caption.fontSize,
        fontWeight: theme.typography.fontWeightBold,
        lineHeight: theme.pxToRem(22),
        paddingBottom: theme.spacing(1.75),
        paddingLeft: theme.spacing(2),
        // Intentional additional padding-right to account for the
        // sort chevron
        paddingRight: theme.spacing(2.5),
        paddingTop: theme.spacing(1.75),
        position: 'sticky',
        textAlign: 'left',
        top: 0,
        whiteSpace: 'nowrap',
        zIndex: 3,
        '&::after': {
            content: "''",
            position: 'absolute',
            left: 0,
            width: '100%',
            bottom: 0,
            borderBottom: "4px solid " + theme.palette.primary.main,
        },
        // First and last headers have additional spacing intentionally
        '&:first-child': {
            paddingLeft: theme.spacing(4),
        },
        '&:last-child': {
            paddingRight: theme.spacing(4),
        },
    },
    rootAlignRight: {
        textAlign: 'right',
    },
    rootPeekIconHover: {
        '&:hover': {
            '& > svg': {
                display: 'inline',
            },
        },
    },
    clickable: {
        cursor: 'pointer',
        userSelect: 'none',
        '&:hover': {
            color: theme.palette.black[500],
            '& > *': {
                color: theme.palette.black[500],
            },
        },
    },
    icon: {
        transition: 'color 0.25s ease, opacity 0.25s ease, transform 0.25s ease',
        margin: theme.spacing(0.375, 0, 0, 0.5),
        color: theme.palette.black.main,
        position: 'absolute',
        top: '25%',
    },
    peekIcon: {
        // we rely on hovering of the root element to set this to
        // visible (see rootPeekIconHover)
        display: 'none',
        opacity: 0.5,
    },
    rotatedIcon: {
        transform: 'rotate(180deg)',
    },
}); }, { name: exports.TableHeaderCellStylesKey });
exports.TableHeaderCell = function (_a) {
    var header = _a.header, _b = _a.isSorting, isSorting = _b === void 0 ? false : _b, sortDirection = _a.sortDirection, onClick = _a.onClick, index = _a.index, headingsCount = _a.headingsCount, rootProps = __rest(_a, ["header", "isSorting", "sortDirection", "onClick", "index", "headingsCount"]);
    var classes = exports.useStyles({});
    var handleClick = function () {
        onClick === null || onClick === void 0 ? void 0 : onClick({ index: index, sortDirection: sortDirection, header: header });
    };
    var canSort = onClick && header.onSort;
    var Tag = !(header === null || header === void 0 ? void 0 : header.content) && !header.label ? 'td' : 'th';
    return (React.createElement(Tag, __assign({ className: clsx_1.default(classes.root, header.onSort && classes.clickable, canSort && classes.rootPeekIconHover, 
        // Rules of alignment:
        // - `header.align` wins over default behavior
        // - If this is the first header and there is only one column for the table
        //   then it is left-aligned
        // - If this is the last header and there is more than one column, then
        //   it is right-aligned
        // - Allow for left alignment override on last header
        // - Fallback behavior is left aligned (specified by root class)
        ((!header.align && headingsCount > 1 && index === headingsCount - 1) ||
            (header === null || header === void 0 ? void 0 : header.align) === 'right') &&
            classes.rootAlignRight, header.className), onClick: canSort ? handleClick : undefined, role: "columnheader", "aria-sort": !isSorting || !sortDirection
            ? 'none'
            : sortDirection === 'asc'
                ? 'ascending'
                : 'descending' }, rootProps),
        header.content ? header.content(header) : header.label,
        (!sortDirection || !isSorting) && canSort && (React.createElement(chromicons_1.ChevronDown, { className: clsx_1.default(classes.icon, classes.peekIcon, classes.rotatedIcon), role: "img", "aria-hidden": true, width: 18, height: 18 })),
        isSorting && sortDirection && (React.createElement(chromicons_1.ChevronDown, { className: clsx_1.default(classes.icon, sortDirection === 'asc' && classes.rotatedIcon), role: "img", "aria-hidden": true, width: 18, height: 18 }))));
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFibGVIZWFkZXJDZWxsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVGFibGVNb2R1bGUvVGFibGVIZWFkZXJDZWxsLnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsOENBQXdCO0FBQ3hCLDJDQUErQjtBQUMvQixtREFBbUQ7QUFDbkQsNENBQWdEO0FBSW5DLFFBQUEsd0JBQXdCLEdBQUcsdUJBQXVCLENBQUM7QUFFbkQsUUFBQSxTQUFTLEdBQUcsa0JBQVUsQ0FDakMsVUFBQyxLQUFLLElBQUssT0FBQSxDQUFDO0lBQ1YsSUFBSSxFQUFFO1FBQ0osVUFBVSxFQUFFLGtCQUFrQjtRQUM5QixVQUFVLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSztRQUN0QyxjQUFjLEVBQUUsVUFBVTtRQUMxQixhQUFhLEVBQUUsQ0FBQztRQUNoQixRQUFRLEVBQUUsS0FBSyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsUUFBUTtRQUMzQyxVQUFVLEVBQUUsS0FBSyxDQUFDLFVBQVUsQ0FBQyxjQUFjO1FBQzNDLFVBQVUsRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztRQUM3QixhQUFhLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFDbEMsV0FBVyxFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQzdCLDBEQUEwRDtRQUMxRCxlQUFlO1FBQ2YsWUFBWSxFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO1FBQ2hDLFVBQVUsRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztRQUMvQixRQUFRLEVBQUUsUUFBUTtRQUNsQixTQUFTLEVBQUUsTUFBTTtRQUNqQixHQUFHLEVBQUUsQ0FBQztRQUNOLFVBQVUsRUFBRSxRQUFRO1FBQ3BCLE1BQU0sRUFB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QyxLQUFLLHVCQUVWLEtBQUssRUFBRSxFQUFFLEVBQ1QsTUFBTSxFQUFFLEVBQUUsR0FDVixDQUNILENBQ0csQ0FDUCxDQUFDO0FBQ0osQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDaGV2cm9uRG93biB9IGZyb20gJ0BsaWZlb21pYy9jaHJvbWljb25zJztcbmltcG9ydCB7IG1ha2VTdHlsZXMgfSBmcm9tICcuLi8uLi9zdHlsZXMvaW5kZXgnO1xuaW1wb3J0IHsgR2V0Q2xhc3NlcyB9IGZyb20gJy4uLy4uL3R5cGVVdGlscyc7XG5pbXBvcnQgeyBUYWJsZVNvcnREaXJlY3Rpb24sIFRhYmxlSGVhZGVyLCBUYWJsZVNvcnRDbGlja1Byb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBUYWJsZUhlYWRlckNlbGxTdHlsZXNLZXkgPSAnQ2hyb21hVGFibGVIZWFkZXJDZWxsJztcblxuZXhwb3J0IGNvbnN0IHVzZVN0eWxlcyA9IG1ha2VTdHlsZXMoXG4gICh0aGVtZSkgPT4gKHtcbiAgICByb290OiB7XG4gICAgICB0cmFuc2l0aW9uOiAnY29sb3IgMC4yNXMgZWFzZScsXG4gICAgICBiYWNrZ3JvdW5kOiB0aGVtZS5wYWxldHRlLmNvbW1vbi53aGl0ZSxcbiAgICAgIGJvcmRlckNvbGxhcHNlOiAnY29sbGFwc2UnLFxuICAgICAgYm9yZGVyU3BhY2luZzogMCxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LmNhcHRpb24uZm9udFNpemUsXG4gICAgICBmb250V2VpZ2h0OiB0aGVtZS50eXBvZ3JhcGh5LmZvbnRXZWlnaHRCb2xkLFxuICAgICAgbGluZUhlaWdodDogdGhlbWUucHhUb1JlbSgyMiksXG4gICAgICBwYWRkaW5nQm90dG9tOiB0aGVtZS5zcGFjaW5nKDEuNzUpLFxuICAgICAgcGFkZGluZ0xlZnQ6IHRoZW1lLnNwYWNpbmcoMiksXG4gICAgICAvLyBJbnRlbnRpb25hbCBhZGRpdGlvbmFsIHBhZGRpbmctcmlnaHQgdG8gYWNjb3VudCBmb3IgdGhlXG4gICAgICAvLyBzb3J0IGNoZXZyb25cbiAgICAgIHBhZGRpbmdSaWdodDogdGhlbWUuc3BhY2luZygyLjUpLFxuICAgICAgcGFkZGluZ1RvcDogdGhlbWUuc3BhY2luZygxLjc1KSxcbiAgICAgIHBvc2l0aW9uOiAnc3RpY2t5JyxcbiAgICAgIHRleHRBbGlnbjogJ2xlZnQnLFxuICAgICAgdG9wOiAwLFxuICAgICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgICB6SW5kZXg6IDMsXG4gICAgICAnJjo6YWZ0ZXInOiB7XG4gICAgICAgIGNvbnRlbnQ6IGAnJ2AsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIGJvcmRlckJvdHRvbTogYDRweCBzb2xpZCAke3RoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWlufWAsXG4gICAgICB9LFxuICAgICAgLy8gRmlyc3QgYW5kIGxhc3QgaGVhZGVycyBoYXZlIGFkZGl0aW9uYWwgc3BhY2luZyBpbnRlbnRpb25hbGx5XG4gICAgICAnJjpmaXJzdC1jaGlsZCc6IHtcbiAgICAgICAgcGFkZGluZ0xlZnQ6IHRoZW1lLnNwYWNpbmcoNCksXG4gICAgICB9LFxuICAgICAgJyY6bGFzdC1jaGlsZCc6IHtcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiB0aGVtZS5zcGFjaW5nKDQpLFxuICAgICAgfSxcbiAgICB9LFxuICAgIHJvb3RBbGlnblJpZ2h0OiB7XG4gICAgICB0ZXh0QWxpZ246ICdyaWdodCcsXG4gICAgfSxcbiAgICByb290UGVla0ljb25Ib3Zlcjoge1xuICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgICcmID4gc3ZnJzoge1xuICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUnLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIGNsaWNrYWJsZToge1xuICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuYmxhY2tbNTAwXSxcbiAgICAgICAgJyYgPiAqJzoge1xuICAgICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLmJsYWNrWzUwMF0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAgaWNvbjoge1xuICAgICAgdHJhbnNpdGlvbjogJ2NvbG9yIDAuMjVzIGVhc2UsIG9wYWNpdHkgMC4yNXMgZWFzZSwgdHJhbnNmb3JtIDAuMjVzIGVhc2UnLFxuICAgICAgbWFyZ2luOiB0aGVtZS5zcGFjaW5nKDAuMzc1LCAwLCAwLCAwLjUpLFxuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuYmxhY2subWFpbixcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAnMjUlJyxcbiAgICB9LFxuICAgIHBlZWtJY29uOiB7XG4gICAgICAvLyB3ZSByZWx5IG9uIGhvdmVyaW5nIG9mIHRoZSByb290IGVsZW1lbnQgdG8gc2V0IHRoaXMgdG9cbiAgICAgIC8vIHZpc2libGUgKHNlZSByb290UGVla0ljb25Ib3ZlcilcbiAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgIG9wYWNpdHk6IDAuNSxcbiAgICB9LFxuICAgIHJvdGF0ZWRJY29uOiB7XG4gICAgICB0cmFuc2Zvcm06ICdyb3RhdGUoMTgwZGVnKScsXG4gICAgfSxcbiAgfSksXG4gIHsgbmFtZTogVGFibGVIZWFkZXJDZWxsU3R5bGVzS2V5IH1cbik7XG5cbmV4cG9ydCB0eXBlIFRhYmxlSGVhZGVyQ2VsbENsYXNzZXMgPSBHZXRDbGFzc2VzPHR5cGVvZiB1c2VTdHlsZXM+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlSGVhZGVyQ2VsbFByb3BzIGV4dGVuZHMgVGFibGVTb3J0RGlyZWN0aW9uIHtcbiAgaXNTb3J0aW5nPzogYm9vbGVhbjtcbiAgaGVhZGVyOiBUYWJsZUhlYWRlcjtcbiAgb25DbGljaz86IChoZWFkZXI6IFRhYmxlU29ydENsaWNrUHJvcHMpID0+IGFueTtcbiAgaW5kZXg6IG51bWJlcjtcbiAgaGVhZGluZ3NDb3VudDogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgVGFibGVIZWFkZXJDZWxsOiBSZWFjdC5GQzxUYWJsZUhlYWRlckNlbGxQcm9wcz4gPSAoe1xuICBoZWFkZXIsXG4gIGlzU29ydGluZyA9IGZhbHNlLFxuICBzb3J0RGlyZWN0aW9uLFxuICBvbkNsaWNrLFxuICBpbmRleCxcbiAgaGVhZGluZ3NDb3VudCxcbiAgLi4ucm9vdFByb3BzXG59KSA9PiB7XG4gIGNvbnN0IGNsYXNzZXMgPSB1c2VTdHlsZXMoe30pO1xuXG4gIGNvbnN0IGhhbmRsZUNsaWNrID0gKCkgPT4ge1xuICAgIG9uQ2xpY2s/Lih7IGluZGV4LCBzb3J0RGlyZWN0aW9uLCBoZWFkZXIgfSk7XG4gIH07XG5cbiAgY29uc3QgY2FuU29ydCA9IG9uQ2xpY2sgJiYgaGVhZGVyLm9uU29ydDtcblxuICBjb25zdCBUYWcgPSAhaGVhZGVyPy5jb250ZW50ICYmICFoZWFkZXIubGFiZWwgPyAndGQnIDogJ3RoJztcblxuICByZXR1cm4gKFxuICAgIDxUYWdcbiAgICAgIGNsYXNzTmFtZT17Y2xzeChcbiAgICAgICAgY2xhc3Nlcy5yb290LFxuICAgICAgICBoZWFkZXIub25Tb3J0ICYmIGNsYXNzZXMuY2xpY2thYmxlLFxuICAgICAgICBjYW5Tb3J0ICYmIGNsYXNzZXMucm9vdFBlZWtJY29uSG92ZXIsXG4gICAgICAgIC8vIFJ1bGVzIG9mIGFsaWdubWVudDpcbiAgICAgICAgLy8gLSBgaGVhZGVyLmFsaWduYCB3aW5zIG92ZXIgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgICAvLyAtIElmIHRoaXMgaXMgdGhlIGZpcnN0IGhlYWRlciBhbmQgdGhlcmUgaXMgb25seSBvbmUgY29sdW1uIGZvciB0aGUgdGFibGVcbiAgICAgICAgLy8gICB0aGVuIGl0IGlzIGxlZnQtYWxpZ25lZFxuICAgICAgICAvLyAtIElmIHRoaXMgaXMgdGhlIGxhc3QgaGVhZGVyIGFuZCB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGNvbHVtbiwgdGhlblxuICAgICAgICAvLyAgIGl0IGlzIHJpZ2h0LWFsaWduZWRcbiAgICAgICAgLy8gLSBBbGxvdyBmb3IgbGVmdCBhbGlnbm1lbnQgb3ZlcnJpZGUgb24gbGFzdCBoZWFkZXJcbiAgICAgICAgLy8gLSBGYWxsYmFjayBiZWhhdmlvciBpcyBsZWZ0IGFsaWduZWQgKHNwZWNpZmllZCBieSByb290IGNsYXNzKVxuICAgICAgICAoKCFoZWFkZXIuYWxpZ24gJiYgaGVhZGluZ3NDb3VudCA+IDEgJiYgaW5kZXggPT09IGhlYWRpbmdzQ291bnQgLSAxKSB8fFxuICAgICAgICAgIGhlYWRlcj8uYWxpZ24gPT09ICdyaWdodCcpICYmXG4gICAgICAgICAgY2xhc3Nlcy5yb290QWxpZ25SaWdodCxcbiAgICAgICAgaGVhZGVyLmNsYXNzTmFtZVxuICAgICAgKX1cbiAgICAgIG9uQ2xpY2s9e2NhblNvcnQgPyBoYW5kbGVDbGljayA6IHVuZGVmaW5lZH1cbiAgICAgIHJvbGU9XCJjb2x1bW5oZWFkZXJcIlxuICAgICAgYXJpYS1zb3J0PXtcbiAgICAgICAgIWlzU29ydGluZyB8fCAhc29ydERpcmVjdGlvblxuICAgICAgICAgID8gJ25vbmUnXG4gICAgICAgICAgOiBzb3J0RGlyZWN0aW9uID09PSAnYXNjJ1xuICAgICAgICAgID8gJ2FzY2VuZGluZydcbiAgICAgICAgICA6ICdkZXNjZW5kaW5nJ1xuICAgICAgfVxuICAgICAgey4uLnJvb3RQcm9wc31cbiAgICA+XG4gICAgICB7aGVhZGVyLmNvbnRlbnQgPyBoZWFkZXIuY29udGVudChoZWFkZXIpIDogaGVhZGVyLmxhYmVsfVxuICAgICAgey8qIFdlIGFyZW4ndCBhY3RpdmVseSBzb3J0aW5nIHRoaXMgY29sdW1uLCBidXQgd2Ugd2FudCB0byBkaXNwbGF5IGEgXCJwZWVrXCIgaWNvbiBzbyB0aGV5IGtub3cgdGhleSBjYW4gc29ydCBpdCAqL31cbiAgICAgIHsoIXNvcnREaXJlY3Rpb24gfHwgIWlzU29ydGluZykgJiYgY2FuU29ydCAmJiAoXG4gICAgICAgIDxDaGV2cm9uRG93blxuICAgICAgICAgIGNsYXNzTmFtZT17Y2xzeChjbGFzc2VzLmljb24sIGNsYXNzZXMucGVla0ljb24sIGNsYXNzZXMucm90YXRlZEljb24pfVxuICAgICAgICAgIHJvbGU9XCJpbWdcIlxuICAgICAgICAgIGFyaWEtaGlkZGVuXG4gICAgICAgICAgd2lkdGg9ezE4fVxuICAgICAgICAgIGhlaWdodD17MTh9XG4gICAgICAgIC8+XG4gICAgICApfVxuICAgICAgey8qIFdlIGhhdmUgYSBzb3J0IGFjdGl2ZSAqL31cbiAgICAgIHtpc1NvcnRpbmcgJiYgc29ydERpcmVjdGlvbiAmJiAoXG4gICAgICAgIDxDaGV2cm9uRG93blxuICAgICAgICAgIGNsYXNzTmFtZT17Y2xzeChcbiAgICAgICAgICAgIGNsYXNzZXMuaWNvbixcbiAgICAgICAgICAgIHNvcnREaXJlY3Rpb24gPT09ICdhc2MnICYmIGNsYXNzZXMucm90YXRlZEljb25cbiAgICAgICAgICApfVxuICAgICAgICAgIHJvbGU9XCJpbWdcIlxuICAgICAgICAgIGFyaWEtaGlkZGVuXG4gICAgICAgICAgd2lkdGg9ezE4fVxuICAgICAgICAgIGhlaWdodD17MTh9XG4gICAgICAgIC8+XG4gICAgICApfVxuICAgIDwvVGFnPlxuICApO1xufTtcbiJdfQ==