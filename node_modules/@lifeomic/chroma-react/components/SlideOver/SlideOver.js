"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var styles_1 = require("../../styles");
var react_remove_scroll_1 = require("react-remove-scroll");
var React = __importStar(require("react"));
var clsx_1 = __importDefault(require("clsx"));
exports.SlideOverStylesKey = 'ChromaSlideOver';
exports.useStyles = styles_1.makeStyles(function (theme) { return ({
    '@keyframes fade-in': {
        '0%': {
            opacity: 0,
        },
        '100%': {
            opacity: 1,
        },
    },
    '@keyframes fade-out': {
        '0%': {
            opacity: 1,
        },
        '100%': {
            opacity: 0,
        },
    },
    '@keyframes slide-in': {
        '0%': {
            width: 0,
            maxWidth: 0,
        },
        '100%': {
            maxWidth: '100%',
            width: 'var(--slideover-width)',
        },
    },
    '@keyframes slide-out': {
        '0%': {
            maxWidth: '100%',
            width: 'var(--slideover-width)',
        },
        '100%': {
            width: 0,
            maxWidth: 0,
        },
    },
    root: {
        '--slideover-width': '28rem',
        backgroundColor: theme.palette.common.white,
        bottom: 0,
        display: 'flex',
        position: 'absolute',
        right: 0,
        top: 0,
        zIndex: 100,
        boxShadow: theme.boxShadows.elevatedContent,
        animation: '$slide-in 0.25s ease-in-out',
        transform: 'translate3d(0, 0, 0)',
        '@media (prefers-reduced-motion)': {
            animation: '$slide-in 0.1s ease-in-out',
        },
    },
    transitionClose: {
        animation: '$slide-out 0.2s ease-in-out',
        '@media (prefers-reduced-motion)': {
            animation: '$slide-out 0.1s ease-in-out',
        },
    },
    fadeInAnimation: {
        animation: '$fade-in 1s',
    },
    fadeOutAnimation: {
        animation: '$fade-out 0.15s',
    },
    inner: {
        maxWidth: 'var(--slideover-width)',
        position: 'relative',
        width: '100vw',
    },
    content: {
        backgroundColor: 'white',
        display: 'flex',
        flexDirection: 'column',
        height: '100%',
        overflowY: 'auto',
    },
}); }, { name: exports.SlideOverStylesKey });
exports.SlideOver = function (_a) {
    var additionalClasses = _a.classes, className = _a.className, children = _a.children, _b = _a.isOpen, isOpen = _b === void 0 ? false : _b, rootProps = __rest(_a, ["classes", "className", "children", "isOpen"]);
    var classes = exports.useStyles({});
    // If the two below states get more complicated, may want to move to a
    // useReducer.
    // We use a local state open variable so we can ensure
    // that the keyframe animations finish before we remove the element
    // from the DOM
    var _c = React.useState(isOpen), localIsOpen = _c[0], setLocalIsOpen = _c[1];
    // This is another state variable we use to apply the "slide-out" keyframes
    // and then we leverage the `onAnimationEnd` to know when it's safe to
    // remove this element from the DOM
    var _d = React.useState(false), isTransitioningClosed = _d[0], setIsTransitioningClosed = _d[1];
    React.useEffect(function () {
        if (localIsOpen === false && isOpen === true) {
            setLocalIsOpen(true);
            setIsTransitioningClosed(false);
            return;
        }
        if (localIsOpen === true && isOpen == false) {
            setIsTransitioningClosed(true);
        }
    }, [isOpen, localIsOpen]);
    if (localIsOpen === false) {
        return null;
    }
    return (React.createElement(react_remove_scroll_1.RemoveScroll, { forwardProps: true },
        React.createElement("section", __assign({ className: clsx_1.default(classes.root, additionalClasses === null || additionalClasses === void 0 ? void 0 : additionalClasses.root, isTransitioningClosed && classes.transitionClose, className), onAnimationEnd: function () {
                if (localIsOpen && isTransitioningClosed) {
                    setLocalIsOpen(false);
                }
            } }, rootProps),
            React.createElement("div", { className: clsx_1.default(classes.inner, additionalClasses === null || additionalClasses === void 0 ? void 0 : additionalClasses.inner) },
                React.createElement("div", { className: clsx_1.default(classes.content, classes.fadeInAnimation, isTransitioningClosed && classes.fadeOutAnimation, additionalClasses === null || additionalClasses === void 0 ? void 0 : additionalClasses.content) }, children)))));
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2xpZGVPdmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvU2xpZGVPdmVyL1NsaWRlT3Zlci50c3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLHVDQUEwQztBQUMxQywyREFBbUQ7QUFDbkQsMkNBQStCO0FBQy9CLDhDQUF3QjtBQUVYLFFBQUEsa0JBQWtCLEdBQUcsaUJBQWlCLENBQUM7QUFFdkMsUUFBQSxTQUFTLEdBQUcsbUJBQVUsQ0FDakMsVUFBQyxLQUFLLElBQUssT0FBQSxDQUFDO0lBQ1Ysb0JBQW9CLEVBQUU7UUFDcEIsSUFBSSxFQUFFO1lBQ0osT0FBTyxFQUFFLENBQUM7U0FDWDtRQUNELE1BQU0sRUFBRTtZQUNOLE9BQU8sRUFBRSxDQUFDO1NBQ1g7S0FDRjtJQUNELHFCQUFxQixFQUFFO1FBQ3JCLElBQUksRUFBRTtZQUNKLE9BQU8sRUFBRSxDQUFDO1NBQ1g7UUFDRCxNQUFNLEVBQUU7WUFDTixPQUFPLEVBQUUsQ0FBQztTQUNYO0tBQ0Y7SUFDRCxxQkFBcUIsRUFBRTtRQUNyQixJQUFJLEVBQUU7WUFDSixLQUFLLEVBQUUsQ0FBQztZQUNSLFFBQVEsRUFBRSxDQUFDO1NBQ1o7UUFDRCxNQUFNLEVBQUU7WUFDTixRQUFRLEVBQUUsTUFBTTtZQUNoQixLQUFLLEVBQUUsd0JBQXdCO1NBQ2hDO0tBQ0Y7SUFDRCxzQkFBc0IsRUFBRTtRQUN0QixJQUFJLEVBQUU7WUFDSixRQUFRLEVBQUUsTUFBTTtZQUNoQixLQUFLLEVBQUUsd0JBQXdCO1NBQ2hDO1FBQ0QsTUFBTSxFQUFFO1lBQ04sS0FBSyxFQUFFLENBQUM7WUFDUixRQUFRLEVBQUUsQ0FBQztTQUNaO0tBQ0Y7SUFDRCxJQUFJLEVBQUU7UUFDSixtQkFBbUIsRUFBRSxPQUFPO1FBQzVCLGVBQWUsRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFL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Q0UsU0FBUyxFQUFFLGNBQUksQ0FDYixPQUFPLENBQUMsT0FBTyxFQUNmLE9BQU8sQ0FBQyxlQUFlLEVBQ3ZCLHFCQUFxQixJQUFJLE9BQU8sQ0FBQyxnQkFBZ0IsRUFDakQsaUJBQWlCLGFBQWpCLGlCQUFpQix1QkFBakIsaUJBQWlCLENBQUUsT0FBTyxDQUMzQixJQUVBLFFBQVEsQ0FDTCxDQUNGLENBQ0UsQ0FDRyxDQUNoQixDQUFDO0FBQ0osQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR2V0Q2xhc3NlcyB9IGZyb20gJy4uLy4uL3R5cGVVdGlscyc7XG5pbXBvcnQgeyBtYWtlU3R5bGVzIH0gZnJvbSAnLi4vLi4vc3R5bGVzJztcbmltcG9ydCB7IFJlbW92ZVNjcm9sbCB9IGZyb20gJ3JlYWN0LXJlbW92ZS1zY3JvbGwnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5cbmV4cG9ydCBjb25zdCBTbGlkZU92ZXJTdHlsZXNLZXkgPSAnQ2hyb21hU2xpZGVPdmVyJztcblxuZXhwb3J0IGNvbnN0IHVzZVN0eWxlcyA9IG1ha2VTdHlsZXMoXG4gICh0aGVtZSkgPT4gKHtcbiAgICAnQGtleWZyYW1lcyBmYWRlLWluJzoge1xuICAgICAgJzAlJzoge1xuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgfSxcbiAgICAgICcxMDAlJzoge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgfSxcbiAgICB9LFxuICAgICdAa2V5ZnJhbWVzIGZhZGUtb3V0Jzoge1xuICAgICAgJzAlJzoge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgfSxcbiAgICAgICcxMDAlJzoge1xuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgfSxcbiAgICB9LFxuICAgICdAa2V5ZnJhbWVzIHNsaWRlLWluJzoge1xuICAgICAgJzAlJzoge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgbWF4V2lkdGg6IDAsXG4gICAgICB9LFxuICAgICAgJzEwMCUnOiB7XG4gICAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICAgIHdpZHRoOiAndmFyKC0tc2xpZGVvdmVyLXdpZHRoKScsXG4gICAgICB9LFxuICAgIH0sXG4gICAgJ0BrZXlmcmFtZXMgc2xpZGUtb3V0Jzoge1xuICAgICAgJzAlJzoge1xuICAgICAgICBtYXhXaWR0aDogJzEwMCUnLFxuICAgICAgICB3aWR0aDogJ3ZhcigtLXNsaWRlb3Zlci13aWR0aCknLFxuICAgICAgfSxcbiAgICAgICcxMDAlJzoge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgbWF4V2lkdGg6IDAsXG4gICAgICB9LFxuICAgIH0sXG4gICAgcm9vdDoge1xuICAgICAgJy0tc2xpZGVvdmVyLXdpZHRoJzogJzI4cmVtJyxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5jb21tb24ud2hpdGUsXG4gICAgICBib3R0b206IDAsXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgekluZGV4OiAxMDAsXG4gICAgICBib3hTaGFkb3c6IHRoZW1lLmJveFNoYWRvd3MuZWxldmF0ZWRDb250ZW50LFxuICAgICAgYW5pbWF0aW9uOiAnJHNsaWRlLWluIDAuMjVzIGVhc2UtaW4tb3V0JyxcbiAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICdAbWVkaWEgKHByZWZlcnMtcmVkdWNlZC1tb3Rpb24pJzoge1xuICAgICAgICBhbmltYXRpb246ICckc2xpZGUtaW4gMC4xcyBlYXNlLWluLW91dCcsXG4gICAgICB9LFxuICAgIH0sXG4gICAgdHJhbnNpdGlvbkNsb3NlOiB7XG4gICAgICBhbmltYXRpb246ICckc2xpZGUtb3V0IDAuMnMgZWFzZS1pbi1vdXQnLFxuICAgICAgJ0BtZWRpYSAocHJlZmVycy1yZWR1Y2VkLW1vdGlvbiknOiB7XG4gICAgICAgIGFuaW1hdGlvbjogJyRzbGlkZS1vdXQgMC4xcyBlYXNlLWluLW91dCcsXG4gICAgICB9LFxuICAgIH0sXG4gICAgZmFkZUluQW5pbWF0aW9uOiB7XG4gICAgICBhbmltYXRpb246ICckZmFkZS1pbiAxcycsXG4gICAgfSxcbiAgICBmYWRlT3V0QW5pbWF0aW9uOiB7XG4gICAgICBhbmltYXRpb246ICckZmFkZS1vdXQgMC4xNXMnLFxuICAgIH0sXG4gICAgaW5uZXI6IHtcbiAgICAgIG1heFdpZHRoOiAndmFyKC0tc2xpZGVvdmVyLXdpZHRoKScsXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIHdpZHRoOiAnMTAwdncnLFxuICAgIH0sXG4gICAgY29udGVudDoge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIG92ZXJmbG93WTogJ2F1dG8nLFxuICAgIH0sXG4gIH0pLFxuICB7IG5hbWU6IFNsaWRlT3ZlclN0eWxlc0tleSB9XG4pO1xuXG5leHBvcnQgdHlwZSBTbGlkZU92ZXJDbGFzc2VzID0gR2V0Q2xhc3Nlczx0eXBlb2YgdXNlU3R5bGVzPjtcblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZU92ZXJQcm9wcyB7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgY2xhc3Nlcz86IHtcbiAgICByb290Pzogc3RyaW5nO1xuICAgIGlubmVyPzogc3RyaW5nO1xuICAgIGNvbnRlbnQ/OiBzdHJpbmc7XG4gIH07XG4gIGlzT3Blbj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBTbGlkZU92ZXI6IFJlYWN0LkZDPFNsaWRlT3ZlclByb3BzPiA9ICh7XG4gIGNsYXNzZXM6IGFkZGl0aW9uYWxDbGFzc2VzLFxuICBjbGFzc05hbWUsXG4gIGNoaWxkcmVuLFxuICBpc09wZW4gPSBmYWxzZSxcbiAgLi4ucm9vdFByb3BzXG59KSA9PiB7XG4gIGNvbnN0IGNsYXNzZXMgPSB1c2VTdHlsZXMoe30pO1xuXG4gIC8vIElmIHRoZSB0d28gYmVsb3cgc3RhdGVzIGdldCBtb3JlIGNvbXBsaWNhdGVkLCBtYXkgd2FudCB0byBtb3ZlIHRvIGFcbiAgLy8gdXNlUmVkdWNlci5cblxuICAvLyBXZSB1c2UgYSBsb2NhbCBzdGF0ZSBvcGVuIHZhcmlhYmxlIHNvIHdlIGNhbiBlbnN1cmVcbiAgLy8gdGhhdCB0aGUga2V5ZnJhbWUgYW5pbWF0aW9ucyBmaW5pc2ggYmVmb3JlIHdlIHJlbW92ZSB0aGUgZWxlbWVudFxuICAvLyBmcm9tIHRoZSBET01cbiAgY29uc3QgW2xvY2FsSXNPcGVuLCBzZXRMb2NhbElzT3Blbl0gPSBSZWFjdC51c2VTdGF0ZTxib29sZWFuPihpc09wZW4pO1xuXG4gIC8vIFRoaXMgaXMgYW5vdGhlciBzdGF0ZSB2YXJpYWJsZSB3ZSB1c2UgdG8gYXBwbHkgdGhlIFwic2xpZGUtb3V0XCIga2V5ZnJhbWVzXG4gIC8vIGFuZCB0aGVuIHdlIGxldmVyYWdlIHRoZSBgb25BbmltYXRpb25FbmRgIHRvIGtub3cgd2hlbiBpdCdzIHNhZmUgdG9cbiAgLy8gcmVtb3ZlIHRoaXMgZWxlbWVudCBmcm9tIHRoZSBET01cbiAgY29uc3QgW2lzVHJhbnNpdGlvbmluZ0Nsb3NlZCwgc2V0SXNUcmFuc2l0aW9uaW5nQ2xvc2VkXSA9IFJlYWN0LnVzZVN0YXRlPFxuICAgIGJvb2xlYW5cbiAgPihmYWxzZSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobG9jYWxJc09wZW4gPT09IGZhbHNlICYmIGlzT3BlbiA9PT0gdHJ1ZSkge1xuICAgICAgc2V0TG9jYWxJc09wZW4odHJ1ZSk7XG4gICAgICBzZXRJc1RyYW5zaXRpb25pbmdDbG9zZWQoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsb2NhbElzT3BlbiA9PT0gdHJ1ZSAmJiBpc09wZW4gPT0gZmFsc2UpIHtcbiAgICAgIHNldElzVHJhbnNpdGlvbmluZ0Nsb3NlZCh0cnVlKTtcbiAgICB9XG4gIH0sIFtpc09wZW4sIGxvY2FsSXNPcGVuXSk7XG5cbiAgaWYgKGxvY2FsSXNPcGVuID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8UmVtb3ZlU2Nyb2xsIGZvcndhcmRQcm9wcz5cbiAgICAgIDxzZWN0aW9uXG4gICAgICAgIGNsYXNzTmFtZT17Y2xzeChcbiAgICAgICAgICBjbGFzc2VzLnJvb3QsXG4gICAgICAgICAgYWRkaXRpb25hbENsYXNzZXM/LnJvb3QsXG4gICAgICAgICAgaXNUcmFuc2l0aW9uaW5nQ2xvc2VkICYmIGNsYXNzZXMudHJhbnNpdGlvbkNsb3NlLFxuICAgICAgICAgIGNsYXNzTmFtZVxuICAgICAgICApfVxuICAgICAgICBvbkFuaW1hdGlvbkVuZD17KCkgPT4ge1xuICAgICAgICAgIGlmIChsb2NhbElzT3BlbiAmJiBpc1RyYW5zaXRpb25pbmdDbG9zZWQpIHtcbiAgICAgICAgICAgIHNldExvY2FsSXNPcGVuKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH19XG4gICAgICAgIHsuLi5yb290UHJvcHN9XG4gICAgICA+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbHN4KGNsYXNzZXMuaW5uZXIsIGFkZGl0aW9uYWxDbGFzc2VzPy5pbm5lcil9PlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xzeChcbiAgICAgICAgICAgICAgY2xhc3Nlcy5jb250ZW50LFxuICAgICAgICAgICAgICBjbGFzc2VzLmZhZGVJbkFuaW1hdGlvbixcbiAgICAgICAgICAgICAgaXNUcmFuc2l0aW9uaW5nQ2xvc2VkICYmIGNsYXNzZXMuZmFkZU91dEFuaW1hdGlvbixcbiAgICAgICAgICAgICAgYWRkaXRpb25hbENsYXNzZXM/LmNvbnRlbnRcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvc2VjdGlvbj5cbiAgICA8L1JlbW92ZVNjcm9sbD5cbiAgKTtcbn07XG4iXX0=