"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var styles_1 = require("../../styles");
var framer_motion_1 = require("framer-motion");
var React = __importStar(require("react"));
var clsx_1 = __importDefault(require("clsx"));
exports.LinearProgressStylesKey = 'ChromaLinearProgress';
exports.useStyles = styles_1.makeStyles(function (theme) { return ({
    root: {
        '--linear-progress-height': '0.25rem',
        '--linear-progress-background-color': theme.palette.black[100],
        '--linear-progress-bar-color': "linear-gradient(135deg,\n        " + theme.palette.primary.light + " 0%,\n        " + theme.palette.primary.main + " 22%,\n        " + theme.palette.purple[700] + " 92%)",
        backgroundColor: 'var(--linear-progress-background-color)',
        height: 'var(--linear-progress-height)',
        overflow: 'hidden',
        position: 'relative',
    },
    bar: {
        background: 'var(--linear-progress-bar-color)',
        bottom: 0,
        height: 'var(--linear-progress-height)',
        left: 0,
        position: 'absolute',
        top: 0,
        transition: 'transform 0.4s linear',
        width: '100%',
    },
    indeterminate: {
        animation: '$chroma-progress-bar-indeterminate 2s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite',
    },
    indeterminateReduced: {
        animation: '$chroma-progress-bar-indeterminate 10s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite',
    },
    '@keyframes chroma-progress-bar-indeterminate': {
        '0%': {
            left: '-100%',
            right: '100%',
        },
        '60%': {
            left: '50%',
            right: '-50%',
        },
        '100%': {
            left: '100%',
            right: '-100%',
        },
    },
}); }, { name: exports.LinearProgressStylesKey });
exports.LinearProgress = function (_a) {
    var className = _a.className, _b = _a.variant, variant = _b === void 0 ? 'determinate' : _b, _c = _a.value, value = _c === void 0 ? 0 : _c, rootProps = __rest(_a, ["className", "variant", "value"]);
    var classes = exports.useStyles({});
    var shouldReduceMotion = framer_motion_1.useReducedMotion();
    return (React.createElement("div", __assign({ className: clsx_1.default(classes.root, className), role: "progressbar", "aria-valuenow": variant === 'determinate' ? value : undefined, "aria-valuemin": variant === 'determinate' ? 0 : undefined, "aria-valuemax": variant === 'determinate' ? 100 : undefined }, rootProps),
        React.createElement("div", { className: clsx_1.default(classes.bar, variant === 'indeterminate' && classes.indeterminate, shouldReduceMotion && classes.indeterminateReduced), style: variant === 'determinate'
                ? { transform: "translateX(-" + (100 - value) + "%)" }
                : undefined })));
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGluZWFyUHJvZ3Jlc3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9MaW5lYXJQcm9ncmVzcy9MaW5lYXJQcm9ncmVzcy50c3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLHVDQUEwQztBQUMxQywrQ0FBaUQ7QUFDakQsMkNBQStCO0FBQy9CLDhDQUF3QjtBQUVYLFFBQUEsdUJBQXVCLEdBQUcsc0JBQXNCLENBQUM7QUFFakQsUUFBQSxTQUFTLEdBQUcsbUJBQVUsQ0FDakMsVUFBQyxLQUFLLElBQUssT0FBQSxDQUFDO0lBQ1YsSUFBSSxFQUFFO1FBQ0osMEJBQTBCLEVBQUUsU0FBUztRQUNyQyxvQ0FBb0MsRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFDOUQsNkJBQTZCLEVBQUUsc0NBQzNCLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssc0JBQzNCLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksdUJBQzFCLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxVQUFPO1FBQ3BDLGVBQWUsRUFBRSx5Q0FBeUM7UUFDMUQsTUFBTSxFQUFFLCtCQUErQjtRQUN2QyxRQUFRLEVBQUUsUUFBUTtRQUNsQixRQUFRLEVBQUUsVUFBVTtLQUNyQjtJQUNELEdBQUcsRUFBRTtRQUNILFVBQVUsRUFBRSxrQ0FBa0M7UUFDOUMsTUFBTSxFQUFFLENBQUM7UUFDVCxNQUFNLEVBQUUsK0JBQStCO1FBQ3ZDLElBQUksRUFBRSxDQUFDO1FBQ1AsUUFBUSxFQUFFLFVBQVU7UUFDcEIsR0FBRyxFQUFFLENBQUM7UUFDTixVQUFVLEVBQUUsdUJBQXVCO1FBQ25DLEtBQUssRUFBRSxNQUFNO0tBQ2Q7SUFDRCxhQUFhLEVBQUU7UUFDYixTQUFTLEVBQ1Asd0ZBQXdGO0tBQzNGO0lBQ0Qsb0JBQW9CLEVBQUU7UUFDcEIsU0FBUyxFQUNQLHlGQUF5RjtLQUM1RjtJQUNELDhDQUE4QyxFQUFFO1FBQzlDLElBQUksRUFBRTtZQUNKLElBQUksRUFBRSxPQUFPO1lBQ2IsS0FBSyxFQUFFLE1BQU07U0FDZDtRQUNELEtBQUssRUFBRTtZQUNMLElBQUksRUFBRSxLQUFLO1lBQ1gsS0FBSyxFQUFFLE1BQU07U0FDZDtRQUNELE1BQU0sRUFBRTtZQUNOLElBQUksRUFBRSxNQUFNO1lBQ1osS0FBSyxFQUFFLE9BQU87U0FDZjtLQUNGO0NBQ0YsQ0FBQyxFQTdDUyxDQTZDVCxFQUNGLEVBQUUsSUFBSSxFQUFFLCtCQUF1QixFQUFFLENBQ2xDLENBQUM7QUFVVyxRQUFBLGNBQWMsR0FBa0MsVUFBQyxFQUs3RDtJQUpDLElBQUEsd0JBQVMsRUFDVCxlQUF1QixFQUF2Qiw0Q0FBdUIsRUFDdkIsYUFBUyxFQUFULDhCQUFTLEVBQ1QseURBQVk7SUFFWixJQUFNLE9BQU8sR0FBRyxpQkFBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBRTlCLElBQU0sa0JBQWtCLEdBQUcsZ0NBQWdCLEVBQUUsQ0FBQztJQUU5QyxPQUFPLENBQ0wsc0NBQ0UsU0FBUyxFQUFFLGNBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxFQUN4QyxJQUFJLEVBQUMsYUFBYSxtQkFDSCxPQUFPLEtBQUssYUFBYSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFNBQVMsbUJBQzdDLE9BQU8sS0FBSyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxtQkFDekMsT0FBTyxLQUFLLGFBQWEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxTQUFTLElBQ3RELFNBQVM7UUFFYiw2QkFDRSxTQUFTLEVBQUUsY0FBSSxDQUNiLE9BQU8sQ0FBQyxHQUFHLEVBQ1gsT0FBTyxLQUFLLGVBQWUsSUFBSSxPQUFPLENBQUMsYUFBYSxFQUNwRCxrQkFBa0IsSUFBSSxPQUFPLENBQUMsb0JBQW9CLENBQ25ELEVBQ0QsS0FBSyxFQUNILE9BQU8sS0FBSyxhQUFhO2dCQUN2QixDQUFDLENBQUMsRUFBRSxTQUFTLEVBQUUsa0JBQWUsR0FBRyxHQUFHLEtBQUssUUFBSSxFQUFFO2dCQUMvQyxDQUFDLENBQUMsU0FBUyxHQUVmLENBQ0UsQ0FDUCxDQUFDO0FBQ0osQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR2V0Q2xhc3NlcyB9IGZyb20gJy4uLy4uL3R5cGVVdGlscyc7XG5pbXBvcnQgeyBtYWtlU3R5bGVzIH0gZnJvbSAnLi4vLi4vc3R5bGVzJztcbmltcG9ydCB7IHVzZVJlZHVjZWRNb3Rpb24gfSBmcm9tICdmcmFtZXItbW90aW9uJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuXG5leHBvcnQgY29uc3QgTGluZWFyUHJvZ3Jlc3NTdHlsZXNLZXkgPSAnQ2hyb21hTGluZWFyUHJvZ3Jlc3MnO1xuXG5leHBvcnQgY29uc3QgdXNlU3R5bGVzID0gbWFrZVN0eWxlcyhcbiAgKHRoZW1lKSA9PiAoe1xuICAgIHJvb3Q6IHtcbiAgICAgICctLWxpbmVhci1wcm9ncmVzcy1oZWlnaHQnOiAnMC4yNXJlbScsXG4gICAgICAnLS1saW5lYXItcHJvZ3Jlc3MtYmFja2dyb3VuZC1jb2xvcic6IHRoZW1lLnBhbGV0dGUuYmxhY2tbMTAwXSxcbiAgICAgICctLWxpbmVhci1wcm9ncmVzcy1iYXItY29sb3InOiBgbGluZWFyLWdyYWRpZW50KDEzNWRlZyxcbiAgICAgICAgJHt0aGVtZS5wYWxldHRlLnByaW1hcnkubGlnaHR9IDAlLFxuICAgICAgICAke3RoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWlufSAyMiUsXG4gICAgICAgICR7dGhlbWUucGFsZXR0ZS5wdXJwbGVbNzAwXX0gOTIlKWAsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd2YXIoLS1saW5lYXItcHJvZ3Jlc3MtYmFja2dyb3VuZC1jb2xvciknLFxuICAgICAgaGVpZ2h0OiAndmFyKC0tbGluZWFyLXByb2dyZXNzLWhlaWdodCknLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgfSxcbiAgICBiYXI6IHtcbiAgICAgIGJhY2tncm91bmQ6ICd2YXIoLS1saW5lYXItcHJvZ3Jlc3MtYmFyLWNvbG9yKScsXG4gICAgICBib3R0b206IDAsXG4gICAgICBoZWlnaHQ6ICd2YXIoLS1saW5lYXItcHJvZ3Jlc3MtaGVpZ2h0KScsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB0b3A6IDAsXG4gICAgICB0cmFuc2l0aW9uOiAndHJhbnNmb3JtIDAuNHMgbGluZWFyJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgfSxcbiAgICBpbmRldGVybWluYXRlOiB7XG4gICAgICBhbmltYXRpb246XG4gICAgICAgICckY2hyb21hLXByb2dyZXNzLWJhci1pbmRldGVybWluYXRlIDJzIGN1YmljLWJlemllcigwLjY1LCAwLjgxNSwgMC43MzUsIDAuMzk1KSBpbmZpbml0ZScsXG4gICAgfSxcbiAgICBpbmRldGVybWluYXRlUmVkdWNlZDoge1xuICAgICAgYW5pbWF0aW9uOlxuICAgICAgICAnJGNocm9tYS1wcm9ncmVzcy1iYXItaW5kZXRlcm1pbmF0ZSAxMHMgY3ViaWMtYmV6aWVyKDAuNjUsIDAuODE1LCAwLjczNSwgMC4zOTUpIGluZmluaXRlJyxcbiAgICB9LFxuICAgICdAa2V5ZnJhbWVzIGNocm9tYS1wcm9ncmVzcy1iYXItaW5kZXRlcm1pbmF0ZSc6IHtcbiAgICAgICcwJSc6IHtcbiAgICAgICAgbGVmdDogJy0xMDAlJyxcbiAgICAgICAgcmlnaHQ6ICcxMDAlJyxcbiAgICAgIH0sXG4gICAgICAnNjAlJzoge1xuICAgICAgICBsZWZ0OiAnNTAlJyxcbiAgICAgICAgcmlnaHQ6ICctNTAlJyxcbiAgICAgIH0sXG4gICAgICAnMTAwJSc6IHtcbiAgICAgICAgbGVmdDogJzEwMCUnLFxuICAgICAgICByaWdodDogJy0xMDAlJyxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSksXG4gIHsgbmFtZTogTGluZWFyUHJvZ3Jlc3NTdHlsZXNLZXkgfVxuKTtcblxuZXhwb3J0IHR5cGUgTGluZWFyUHJvZ3Jlc3NDbGFzc2VzID0gR2V0Q2xhc3Nlczx0eXBlb2YgdXNlU3R5bGVzPjtcblxuZXhwb3J0IGludGVyZmFjZSBMaW5lYXJQcm9ncmVzc1Byb3BzIHtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICB2YWx1ZT86IG51bWJlcjtcbiAgdmFyaWFudD86ICdkZXRlcm1pbmF0ZScgfCAnaW5kZXRlcm1pbmF0ZSc7XG59XG5cbmV4cG9ydCBjb25zdCBMaW5lYXJQcm9ncmVzczogUmVhY3QuRkM8TGluZWFyUHJvZ3Jlc3NQcm9wcz4gPSAoe1xuICBjbGFzc05hbWUsXG4gIHZhcmlhbnQgPSAnZGV0ZXJtaW5hdGUnLFxuICB2YWx1ZSA9IDAsXG4gIC4uLnJvb3RQcm9wc1xufSkgPT4ge1xuICBjb25zdCBjbGFzc2VzID0gdXNlU3R5bGVzKHt9KTtcblxuICBjb25zdCBzaG91bGRSZWR1Y2VNb3Rpb24gPSB1c2VSZWR1Y2VkTW90aW9uKCk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2Nsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUpfVxuICAgICAgcm9sZT1cInByb2dyZXNzYmFyXCJcbiAgICAgIGFyaWEtdmFsdWVub3c9e3ZhcmlhbnQgPT09ICdkZXRlcm1pbmF0ZScgPyB2YWx1ZSA6IHVuZGVmaW5lZH1cbiAgICAgIGFyaWEtdmFsdWVtaW49e3ZhcmlhbnQgPT09ICdkZXRlcm1pbmF0ZScgPyAwIDogdW5kZWZpbmVkfVxuICAgICAgYXJpYS12YWx1ZW1heD17dmFyaWFudCA9PT0gJ2RldGVybWluYXRlJyA/IDEwMCA6IHVuZGVmaW5lZH1cbiAgICAgIHsuLi5yb290UHJvcHN9XG4gICAgPlxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e2Nsc3goXG4gICAgICAgICAgY2xhc3Nlcy5iYXIsXG4gICAgICAgICAgdmFyaWFudCA9PT0gJ2luZGV0ZXJtaW5hdGUnICYmIGNsYXNzZXMuaW5kZXRlcm1pbmF0ZSxcbiAgICAgICAgICBzaG91bGRSZWR1Y2VNb3Rpb24gJiYgY2xhc3Nlcy5pbmRldGVybWluYXRlUmVkdWNlZFxuICAgICAgICApfVxuICAgICAgICBzdHlsZT17XG4gICAgICAgICAgdmFyaWFudCA9PT0gJ2RldGVybWluYXRlJ1xuICAgICAgICAgICAgPyB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoLSR7MTAwIC0gdmFsdWV9JSlgIH1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgIC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuIl19