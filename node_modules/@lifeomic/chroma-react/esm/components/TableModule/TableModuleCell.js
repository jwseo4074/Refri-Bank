var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { getTestProps } from '../../testUtils/getTestProps';
import { useStyles, testIds } from './TableModule';
import * as React from 'react';
import clsx from 'clsx';
export var TableModuleCell = React.memo(function (_a) {
    var _b;
    var maxCellWidth = _a.maxCellWidth, isLastCellInRow = _a.isLastCellInRow, cell = _a.cell, children = _a.children;
    var classes = useStyles({});
    return (React.createElement("td", __assign({ 
        // Rules of alignment:
        // - `cell.align` wins over default behavior
        // - If this is the first cell and there is only one column for the table
        //   then it is left-aligned
        // - If this is the last cell and there is more than one column, then
        //   it is right-aligned
        // - Allow for left alignment override on last cell
        // - Fallback behavior is left aligned (specified by tableRowCell class)
        className: clsx(classes.tableRowCell, ((isLastCellInRow && (cell === null || cell === void 0 ? void 0 : cell.align) !== 'left') ||
            (cell === null || cell === void 0 ? void 0 : cell.align) === 'right') &&
            classes.tableRowCellAlignRight, maxCellWidth && classes.tableRowCellTruncate, (_b = {},
            _b[classes.tableRowCellMaxWidth1] = maxCellWidth === 1,
            _b[classes.tableRowCellMaxWidth2] = maxCellWidth === 2,
            _b), cell.className), role: "cell" }, getTestProps(testIds.bodyCell)), children));
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFibGVNb2R1bGVDZWxsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVGFibGVNb2R1bGUvVGFibGVNb2R1bGVDZWxsLnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUU1RCxPQUFPLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEtBQUssS0FBSyxNQUFNLE9BQU8sQ0FBQztBQUMvQixPQUFPLElBQUksTUFBTSxNQUFNLENBQUM7QUFheEIsTUFBTSxDQUFDLElBQU0sZUFBZSxHQUE4QixLQUFLLENBQUMsSUFBSSxDQUNsRSxVQUFDLEVBQWlEOztRQUEvQyxZQUFZLGtCQUFBLEVBQUUsZUFBZSxxQkFBQSxFQUFFLElBQUksVUFBQSxFQUFFLFFBQVEsY0FBQTtJQUM5QyxJQUFNLE9BQU8sR0FBRyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7SUFFOUIsT0FBTyxDQUNMO1FBQ0Usc0JBQXNCO1FBQ3RCLDRDQUE0QztRQUM1Qyx5RUFBeUU7UUFDekUsNEJBQTRCO1FBQzVCLHFFQUFxRTtRQUNyRSx3QkFBd0I7UUFDeEIsbURBQW1EO1FBQ25ELHdFQUF3RTtRQUN4RSxTQUFTLEVBQUUsSUFBSSxDQUNiLE9BQU8sQ0FBQyxZQUFZLEVBQ3BCLENBQUMsQ0FBQyxlQUFlLElBQUksQ0FBQSxJQUFJLGFBQUosSUFBSSx1QkFBSixJQUFJLENBQUUsS0FBSyxNQUFLLE1BQU0sQ0FBQztZQUMxQyxDQUFBLElBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxLQUFLLE1BQUssT0FBTyxDQUFDO1lBQ3hCLE9BQU8sQ0FBQyxzQkFBc0IsRUFDaEMsWUFBWSxJQUFJLE9BQU8sQ0FBQyxvQkFBb0I7WUFFMUMsR0FBQyxPQUFPLENBQUMscUJBQXFCLElBQUcsWUFBWSxLQUFLLENBQUM7WUFDbkQsR0FBQyxPQUFPLENBQUMscUJBQXFCLElBQUcsWUFBWSxLQUFLLENBQUM7aUJBRXJELElBQUksQ0FBQyxTQUFTLENBQ2YsRUFDRCxJQUFJLEVBQUMsTUFBTSxJQUNQLFlBQVksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEdBRWpDLFFBQVEsQ0FDTixDQUNOLENBQUM7QUFDSixDQUFDLENBQ0YsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFRlc3RQcm9wcyB9IGZyb20gJy4uLy4uL3Rlc3RVdGlscy9nZXRUZXN0UHJvcHMnO1xuaW1wb3J0IHsgVGFibGVDZWxsIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyB1c2VTdHlsZXMsIHRlc3RJZHMgfSBmcm9tICcuL1RhYmxlTW9kdWxlJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlTW9kdWxlQ2VsbFxuICBleHRlbmRzIFJlYWN0LkRldGFpbGVkSFRNTFByb3BzPFxuICAgIFJlYWN0LkhUTUxBdHRyaWJ1dGVzPEhUTUxUYWJsZUVsZW1lbnQ+LFxuICAgIEhUTUxUYWJsZUVsZW1lbnRcbiAgPiB7XG4gIGNoaWxkcmVuOiBhbnk7XG4gIG1heENlbGxXaWR0aD86IDEgfCAyO1xuICBpc0xhc3RDZWxsSW5Sb3c6IGJvb2xlYW47XG4gIGNlbGw6IFRhYmxlQ2VsbDtcbn1cblxuZXhwb3J0IGNvbnN0IFRhYmxlTW9kdWxlQ2VsbDogUmVhY3QuRkM8VGFibGVNb2R1bGVDZWxsPiA9IFJlYWN0Lm1lbW8oXG4gICh7IG1heENlbGxXaWR0aCwgaXNMYXN0Q2VsbEluUm93LCBjZWxsLCBjaGlsZHJlbiB9KSA9PiB7XG4gICAgY29uc3QgY2xhc3NlcyA9IHVzZVN0eWxlcyh7fSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPHRkXG4gICAgICAgIC8vIFJ1bGVzIG9mIGFsaWdubWVudDpcbiAgICAgICAgLy8gLSBgY2VsbC5hbGlnbmAgd2lucyBvdmVyIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgICAgLy8gLSBJZiB0aGlzIGlzIHRoZSBmaXJzdCBjZWxsIGFuZCB0aGVyZSBpcyBvbmx5IG9uZSBjb2x1bW4gZm9yIHRoZSB0YWJsZVxuICAgICAgICAvLyAgIHRoZW4gaXQgaXMgbGVmdC1hbGlnbmVkXG4gICAgICAgIC8vIC0gSWYgdGhpcyBpcyB0aGUgbGFzdCBjZWxsIGFuZCB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGNvbHVtbiwgdGhlblxuICAgICAgICAvLyAgIGl0IGlzIHJpZ2h0LWFsaWduZWRcbiAgICAgICAgLy8gLSBBbGxvdyBmb3IgbGVmdCBhbGlnbm1lbnQgb3ZlcnJpZGUgb24gbGFzdCBjZWxsXG4gICAgICAgIC8vIC0gRmFsbGJhY2sgYmVoYXZpb3IgaXMgbGVmdCBhbGlnbmVkIChzcGVjaWZpZWQgYnkgdGFibGVSb3dDZWxsIGNsYXNzKVxuICAgICAgICBjbGFzc05hbWU9e2Nsc3goXG4gICAgICAgICAgY2xhc3Nlcy50YWJsZVJvd0NlbGwsXG4gICAgICAgICAgKChpc0xhc3RDZWxsSW5Sb3cgJiYgY2VsbD8uYWxpZ24gIT09ICdsZWZ0JykgfHxcbiAgICAgICAgICAgIGNlbGw/LmFsaWduID09PSAncmlnaHQnKSAmJlxuICAgICAgICAgICAgY2xhc3Nlcy50YWJsZVJvd0NlbGxBbGlnblJpZ2h0LFxuICAgICAgICAgIG1heENlbGxXaWR0aCAmJiBjbGFzc2VzLnRhYmxlUm93Q2VsbFRydW5jYXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIFtjbGFzc2VzLnRhYmxlUm93Q2VsbE1heFdpZHRoMV06IG1heENlbGxXaWR0aCA9PT0gMSxcbiAgICAgICAgICAgIFtjbGFzc2VzLnRhYmxlUm93Q2VsbE1heFdpZHRoMl06IG1heENlbGxXaWR0aCA9PT0gMixcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNlbGwuY2xhc3NOYW1lXG4gICAgICAgICl9XG4gICAgICAgIHJvbGU9XCJjZWxsXCJcbiAgICAgICAgey4uLmdldFRlc3RQcm9wcyh0ZXN0SWRzLmJvZHlDZWxsKX1cbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC90ZD5cbiAgICApO1xuICB9XG4pO1xuIl19