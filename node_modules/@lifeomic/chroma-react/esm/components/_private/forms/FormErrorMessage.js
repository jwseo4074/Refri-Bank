var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import clsx from 'clsx';
import * as React from 'react';
import { makeStyles } from '../../../styles';
import { Text } from '../../Text';
export var FormErrorMessageStylesKey = 'ChromaFormErrorMessage';
var useStyles = makeStyles(function (theme) { return ({
    root: {
        color: theme.palette.error.main,
        lineHeight: 1.25,
        marginTop: theme.spacing(0.375),
    },
    inverse: {
        color: theme.palette.error[50],
    },
}); }, { name: FormErrorMessageStylesKey });
export var FormErrorMessage = function (_a) {
    var className = _a.className, describedById = _a.describedById, color = _a.color, children = _a.children, rootElementId = _a.rootElementId, rootProps = __rest(_a, ["className", "describedById", "color", "children", "rootElementId"]);
    var classes = useStyles({});
    return (React.createElement(Text, __assign({ size: "caption", weight: "bold", "error-for": rootElementId, id: describedById, "aria-live": "assertive", role: "alert", className: clsx(classes.root, color === 'inverse' && classes.inverse, className) }, rootProps), children));
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRm9ybUVycm9yTWVzc2FnZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL19wcml2YXRlL2Zvcm1zL0Zvcm1FcnJvck1lc3NhZ2UudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxPQUFPLElBQUksTUFBTSxNQUFNLENBQUM7QUFDeEIsT0FBTyxLQUFLLEtBQUssTUFBTSxPQUFPLENBQUM7QUFDL0IsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRTdDLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFHbEMsTUFBTSxDQUFDLElBQU0seUJBQXlCLEdBQUcsd0JBQXdCLENBQUM7QUFFbEUsSUFBTSxTQUFTLEdBQUcsVUFBVSxDQUMxQixVQUFDLEtBQUssSUFBSyxPQUFBLENBQUM7SUFDVixJQUFJLEVBQUU7UUFDSixLQUFLLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSTtRQUMvQixVQUFVLEVBQUUsSUFBSTtRQUNoQixTQUFTLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUM7S0FDaEM7SUFDRCxPQUFPLEVBQUU7UUFDUCxLQUFLLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO0tBQy9CO0NBQ0YsQ0FBQyxFQVRTLENBU1QsRUFDRixFQUFFLElBQUksRUFBRSx5QkFBeUIsRUFBRSxDQUNwQyxDQUFDO0FBTUYsTUFBTSxDQUFDLElBQU0sZ0JBQWdCLEdBQW9DLFVBQUMsRUFPakU7SUFOQyxJQUFBLFNBQVMsZUFBQSxFQUNULGFBQWEsbUJBQUEsRUFDYixLQUFLLFdBQUEsRUFDTCxRQUFRLGNBQUEsRUFDUixhQUFhLG1CQUFBLEVBQ1YsU0FBUyxjQU5vRCxvRUFPakUsQ0FEYTtJQUVaLElBQU0sT0FBTyxHQUFHLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUM5QixPQUFPLENBQ0wsb0JBQUMsSUFBSSxhQUNILElBQUksRUFBQyxTQUFTLEVBQ2QsTUFBTSxFQUFDLE1BQU0sZUFDRixhQUFhLEVBQ3hCLEVBQUUsRUFBRSxhQUFhLGVBQ1AsV0FBVyxFQUNyQixJQUFJLEVBQUMsT0FBTyxFQUNaLFNBQVMsRUFBRSxJQUFJLENBQ2IsT0FBTyxDQUFDLElBQUksRUFDWixLQUFLLEtBQUssU0FBUyxJQUFJLE9BQU8sQ0FBQyxPQUFPLEVBQ3RDLFNBQVMsQ0FDVixJQUNHLFNBQVMsR0FFWixRQUFRLENBQ0osQ0FDUixDQUFDO0FBQ0osQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBtYWtlU3R5bGVzIH0gZnJvbSAnLi4vLi4vLi4vc3R5bGVzJztcbmltcG9ydCB7IEdldENsYXNzZXMgfSBmcm9tICcuLi8uLi8uLi90eXBlVXRpbHMnO1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL1RleHQnO1xuaW1wb3J0IHsgQmFzZUZvcm1NZXNzYWdlIH0gZnJvbSAnLi9Gb3JtRWxlbWVudFV0aWxzJztcblxuZXhwb3J0IGNvbnN0IEZvcm1FcnJvck1lc3NhZ2VTdHlsZXNLZXkgPSAnQ2hyb21hRm9ybUVycm9yTWVzc2FnZSc7XG5cbmNvbnN0IHVzZVN0eWxlcyA9IG1ha2VTdHlsZXMoXG4gICh0aGVtZSkgPT4gKHtcbiAgICByb290OiB7XG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5lcnJvci5tYWluLFxuICAgICAgbGluZUhlaWdodDogMS4yNSxcbiAgICAgIG1hcmdpblRvcDogdGhlbWUuc3BhY2luZygwLjM3NSksXG4gICAgfSxcbiAgICBpbnZlcnNlOiB7XG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5lcnJvcls1MF0sXG4gICAgfSxcbiAgfSksXG4gIHsgbmFtZTogRm9ybUVycm9yTWVzc2FnZVN0eWxlc0tleSB9XG4pO1xuXG5leHBvcnQgdHlwZSBGb3JtRXJyb3JNZXNzYWdlQ2xhc3NlcyA9IEdldENsYXNzZXM8dHlwZW9mIHVzZVN0eWxlcz47XG5cbmV4cG9ydCBpbnRlcmZhY2UgRm9ybUVycm9yTWVzc2FnZVByb3BzIGV4dGVuZHMgQmFzZUZvcm1NZXNzYWdlIHt9XG5cbmV4cG9ydCBjb25zdCBGb3JtRXJyb3JNZXNzYWdlOiBSZWFjdC5GQzxGb3JtRXJyb3JNZXNzYWdlUHJvcHM+ID0gKHtcbiAgY2xhc3NOYW1lLFxuICBkZXNjcmliZWRCeUlkLFxuICBjb2xvcixcbiAgY2hpbGRyZW4sXG4gIHJvb3RFbGVtZW50SWQsXG4gIC4uLnJvb3RQcm9wc1xufSkgPT4ge1xuICBjb25zdCBjbGFzc2VzID0gdXNlU3R5bGVzKHt9KTtcbiAgcmV0dXJuIChcbiAgICA8VGV4dFxuICAgICAgc2l6ZT1cImNhcHRpb25cIlxuICAgICAgd2VpZ2h0PVwiYm9sZFwiXG4gICAgICBlcnJvci1mb3I9e3Jvb3RFbGVtZW50SWR9XG4gICAgICBpZD17ZGVzY3JpYmVkQnlJZH1cbiAgICAgIGFyaWEtbGl2ZT1cImFzc2VydGl2ZVwiXG4gICAgICByb2xlPVwiYWxlcnRcIlxuICAgICAgY2xhc3NOYW1lPXtjbHN4KFxuICAgICAgICBjbGFzc2VzLnJvb3QsXG4gICAgICAgIGNvbG9yID09PSAnaW52ZXJzZScgJiYgY2xhc3Nlcy5pbnZlcnNlLFxuICAgICAgICBjbGFzc05hbWVcbiAgICAgICl9XG4gICAgICB7Li4ucm9vdFByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1RleHQ+XG4gICk7XG59O1xuIl19