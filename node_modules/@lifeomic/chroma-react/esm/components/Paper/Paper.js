var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import clsx from 'clsx';
import * as React from 'react';
import { makeStyles } from '../../styles';
import { Box } from '../Box';
export var PaperStylesKey = 'ChromaPaper';
export var useStyles = makeStyles(function (theme) { return ({
    root: {
        background: theme.palette.common.white,
        boxShadow: theme.boxShadows.table,
        borderRadius: theme.pxToRem(3),
    },
    padding0: {
        padding: 0,
    },
    padding1: {
        padding: theme.spacing(1),
    },
    padding2: {
        padding: theme.spacing(2),
    },
}); }, { name: PaperStylesKey });
export var Paper = React.forwardRef(function (_a, ref) {
    var _b;
    var children = _a.children, className = _a.className, _c = _a.padding, padding = _c === void 0 ? 2 : _c, rootProps = __rest(_a, ["children", "className", "padding"]);
    var classes = useStyles({});
    return (React.createElement(Box, __assign({ direction: "column", ref: ref, className: clsx(classes.root, (_b = {},
            _b[classes.padding0] = padding === 0,
            _b[classes.padding1] = padding === 1,
            _b[classes.padding2] = padding === 2,
            _b), className) }, rootProps), children));
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFwZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9QYXBlci9QYXBlci50c3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE9BQU8sSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUN4QixPQUFPLEtBQUssS0FBSyxNQUFNLE9BQU8sQ0FBQztBQUMvQixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBRTFDLE9BQU8sRUFBRSxHQUFHLEVBQVksTUFBTSxRQUFRLENBQUM7QUFFdkMsTUFBTSxDQUFDLElBQU0sY0FBYyxHQUFHLGFBQWEsQ0FBQztBQUU1QyxNQUFNLENBQUMsSUFBTSxTQUFTLEdBQUcsVUFBVSxDQUNqQyxVQUFDLEtBQUssSUFBSyxPQUFBLENBQUM7SUFDVixJQUFJLEVBQUU7UUFDSixVQUFVLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSztRQUN0QyxTQUFTLEVBQUUsS0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFLO1FBQ2pDLFlBQVksRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztLQUMvQjtJQUNELFFBQVEsRUFBRTtRQUNSLE9BQU8sRUFBRSxDQUFDO0tBQ1g7SUFDRCxRQUFRLEVBQUU7UUFDUixPQUFPLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7S0FDMUI7SUFDRCxRQUFRLEVBQUU7UUFDUixPQUFPLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7S0FDMUI7Q0FDRixDQUFDLEVBZlMsQ0FlVCxFQUNGLEVBQUUsSUFBSSxFQUFFLGNBQWMsRUFBRSxDQUN6QixDQUFDO0FBVUYsTUFBTSxDQUFDLElBQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQ25DLFVBQUMsRUFBa0QsRUFBRSxHQUFHOztJQUFyRCxJQUFBLFFBQVEsY0FBQSxFQUFFLFNBQVMsZUFBQSxFQUFFLGVBQVcsRUFBWCxPQUFPLG1CQUFHLENBQUMsS0FBQSxFQUFLLFNBQVMsY0FBaEQsb0NBQWtELENBQUY7SUFDL0MsSUFBTSxPQUFPLEdBQUcsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBRTlCLE9BQU8sQ0FDTCxvQkFBQyxHQUFHLGFBQ0YsU0FBUyxFQUFDLFFBQVEsRUFDbEIsR0FBRyxFQUFFLEdBQUcsRUFDUixTQUFTLEVBQUUsSUFBSSxDQUNiLE9BQU8sQ0FBQyxJQUFJO1lBRVYsR0FBQyxPQUFPLENBQUMsUUFBUSxJQUFHLE9BQU8sS0FBSyxDQUFDO1lBQ2pDLEdBQUMsT0FBTyxDQUFDLFFBQVEsSUFBRyxPQUFPLEtBQUssQ0FBQztZQUNqQyxHQUFDLE9BQU8sQ0FBQyxRQUFRLElBQUcsT0FBTyxLQUFLLENBQUM7aUJBRW5DLFNBQVMsQ0FDVixJQUNHLFNBQVMsR0FFWixRQUFRLENBQ0wsQ0FDUCxDQUFDO0FBQ0osQ0FBQyxDQUNGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IG1ha2VTdHlsZXMgfSBmcm9tICcuLi8uLi9zdHlsZXMnO1xuaW1wb3J0IHsgR2V0Q2xhc3NlcyB9IGZyb20gJy4uLy4uL3R5cGVVdGlscyc7XG5pbXBvcnQgeyBCb3gsIEJveFByb3BzIH0gZnJvbSAnLi4vQm94JztcblxuZXhwb3J0IGNvbnN0IFBhcGVyU3R5bGVzS2V5ID0gJ0Nocm9tYVBhcGVyJztcblxuZXhwb3J0IGNvbnN0IHVzZVN0eWxlcyA9IG1ha2VTdHlsZXMoXG4gICh0aGVtZSkgPT4gKHtcbiAgICByb290OiB7XG4gICAgICBiYWNrZ3JvdW5kOiB0aGVtZS5wYWxldHRlLmNvbW1vbi53aGl0ZSxcbiAgICAgIGJveFNoYWRvdzogdGhlbWUuYm94U2hhZG93cy50YWJsZSxcbiAgICAgIGJvcmRlclJhZGl1czogdGhlbWUucHhUb1JlbSgzKSxcbiAgICB9LFxuICAgIHBhZGRpbmcwOiB7XG4gICAgICBwYWRkaW5nOiAwLFxuICAgIH0sXG4gICAgcGFkZGluZzE6IHtcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMSksXG4gICAgfSxcbiAgICBwYWRkaW5nMjoge1xuICAgICAgcGFkZGluZzogdGhlbWUuc3BhY2luZygyKSxcbiAgICB9LFxuICB9KSxcbiAgeyBuYW1lOiBQYXBlclN0eWxlc0tleSB9XG4pO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBhcGVyT3duUHJvcHMgZXh0ZW5kcyBCb3hQcm9wcyB7XG4gIHBhZGRpbmc/OiAwIHwgMSB8IDI7XG59XG5cbmV4cG9ydCB0eXBlIFBhcGVyQ2xhc3NlcyA9IEdldENsYXNzZXM8dHlwZW9mIHVzZVN0eWxlcz47XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFwZXJQcm9wcyBleHRlbmRzIFBhcGVyT3duUHJvcHMge31cblxuZXhwb3J0IGNvbnN0IFBhcGVyID0gUmVhY3QuZm9yd2FyZFJlZjxIVE1MRGl2RWxlbWVudCwgUGFwZXJQcm9wcz4oXG4gICh7IGNoaWxkcmVuLCBjbGFzc05hbWUsIHBhZGRpbmcgPSAyLCAuLi5yb290UHJvcHMgfSwgcmVmKSA9PiB7XG4gICAgY29uc3QgY2xhc3NlcyA9IHVzZVN0eWxlcyh7fSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEJveFxuICAgICAgICBkaXJlY3Rpb249XCJjb2x1bW5cIlxuICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgY2xhc3NOYW1lPXtjbHN4KFxuICAgICAgICAgIGNsYXNzZXMucm9vdCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBbY2xhc3Nlcy5wYWRkaW5nMF06IHBhZGRpbmcgPT09IDAsXG4gICAgICAgICAgICBbY2xhc3Nlcy5wYWRkaW5nMV06IHBhZGRpbmcgPT09IDEsXG4gICAgICAgICAgICBbY2xhc3Nlcy5wYWRkaW5nMl06IHBhZGRpbmcgPT09IDIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjbGFzc05hbWVcbiAgICAgICAgKX1cbiAgICAgICAgey4uLnJvb3RQcm9wc31cbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9Cb3g+XG4gICAgKTtcbiAgfVxuKTtcbiJdfQ==