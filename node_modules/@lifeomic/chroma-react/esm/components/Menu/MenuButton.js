var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import { makeStyles } from '../../styles';
import { Button } from '../Button';
export var MenuButtonStylesKey = 'ChromaMenuButton';
export var useStyles = makeStyles(function (theme) { return ({
    trailingIcon: {
        width: theme.spacing(2),
        height: theme.spacing(2),
        marginLeft: theme.spacing(1),
        verticalAlign: 'middle',
        position: 'relative',
        top: theme.pxToRem(-1),
    },
}); }, { name: MenuButtonStylesKey });
/** @deprecated Please use `trailingIcon` from Button instead. This will be removed in a future release */
export var MenuButton = React.forwardRef(function (_a, ref) {
    var children = _a.children, TrailingIcon = _a.trailingIcon, rootProps = __rest(_a, ["children", "trailingIcon"]);
    var classes = useStyles({});
    return (React.createElement(Button, __assign({ ref: ref }, rootProps),
        children,
        !!TrailingIcon && (React.createElement(TrailingIcon, { role: "img", "aria-hidden": true, className: classes.trailingIcon }))));
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVudUJ1dHRvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL01lbnUvTWVudUJ1dHRvbi50c3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE9BQU8sS0FBSyxLQUFLLE1BQU0sT0FBTyxDQUFDO0FBQy9CLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFFMUMsT0FBTyxFQUFFLE1BQU0sRUFBZSxNQUFNLFdBQVcsQ0FBQztBQUVoRCxNQUFNLENBQUMsSUFBTSxtQkFBbUIsR0FBRyxrQkFBa0IsQ0FBQztBQUV0RCxNQUFNLENBQUMsSUFBTSxTQUFTLEdBQUcsVUFBVSxDQUNqQyxVQUFDLEtBQUssSUFBSyxPQUFBLENBQUM7SUFDVixZQUFZLEVBQUU7UUFDWixLQUFLLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFDdkIsTUFBTSxFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQ3hCLFVBQVUsRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztRQUM1QixhQUFhLEVBQUUsUUFBUTtRQUN2QixRQUFRLEVBQUUsVUFBVTtRQUNwQixHQUFHLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUN2QjtDQUNGLENBQUMsRUFUUyxDQVNULEVBQ0YsRUFBRSxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsQ0FDOUIsQ0FBQztBQVNGLDBHQUEwRztBQUMxRyxNQUFNLENBQUMsSUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLFVBQVUsQ0FDeEMsVUFBQyxFQUFzRCxFQUFFLEdBQUc7SUFBekQsSUFBQSxRQUFRLGNBQUEsRUFBZ0IsWUFBWSxrQkFBQSxFQUFLLFNBQVMsY0FBcEQsNEJBQXNELENBQUY7SUFDbkQsSUFBTSxPQUFPLEdBQUcsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzlCLE9BQU8sQ0FDTCxvQkFBQyxNQUFNLGFBQUMsR0FBRyxFQUFFLEdBQUcsSUFBTSxTQUFTO1FBQzVCLFFBQVE7UUFDUixDQUFDLENBQUMsWUFBWSxJQUFJLENBQ2pCLG9CQUFDLFlBQVksSUFDWCxJQUFJLEVBQUMsS0FBSyx1QkFFVixTQUFTLEVBQUUsT0FBTyxDQUFDLFlBQVksR0FDL0IsQ0FDSCxDQUNNLENBQ1YsQ0FBQztBQUNKLENBQUMsQ0FDRixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbWFrZVN0eWxlcyB9IGZyb20gJy4uLy4uL3N0eWxlcyc7XG5pbXBvcnQgeyBHZXRDbGFzc2VzIH0gZnJvbSAnLi4vLi4vdHlwZVV0aWxzJztcbmltcG9ydCB7IEJ1dHRvbiwgQnV0dG9uUHJvcHMgfSBmcm9tICcuLi9CdXR0b24nO1xuXG5leHBvcnQgY29uc3QgTWVudUJ1dHRvblN0eWxlc0tleSA9ICdDaHJvbWFNZW51QnV0dG9uJztcblxuZXhwb3J0IGNvbnN0IHVzZVN0eWxlcyA9IG1ha2VTdHlsZXMoXG4gICh0aGVtZSkgPT4gKHtcbiAgICB0cmFpbGluZ0ljb246IHtcbiAgICAgIHdpZHRoOiB0aGVtZS5zcGFjaW5nKDIpLFxuICAgICAgaGVpZ2h0OiB0aGVtZS5zcGFjaW5nKDIpLFxuICAgICAgbWFyZ2luTGVmdDogdGhlbWUuc3BhY2luZygxKSxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICB0b3A6IHRoZW1lLnB4VG9SZW0oLTEpLFxuICAgIH0sXG4gIH0pLFxuICB7IG5hbWU6IE1lbnVCdXR0b25TdHlsZXNLZXkgfVxuKTtcblxuZXhwb3J0IHR5cGUgTWVudUJ1dHRvbkNsYXNzZXMgPSBHZXRDbGFzc2VzPHR5cGVvZiB1c2VTdHlsZXM+O1xuXG5leHBvcnQgaW50ZXJmYWNlIE1lbnVCdXR0b25Qcm9wcyBleHRlbmRzIEJ1dHRvblByb3BzIHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIHRyYWlsaW5nSWNvbj86IFJlYWN0LkNvbXBvbmVudFR5cGU8UmVhY3QuU1ZHUHJvcHM8U1ZHU1ZHRWxlbWVudD4+O1xufVxuXG4vKiogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBgdHJhaWxpbmdJY29uYCBmcm9tIEJ1dHRvbiBpbnN0ZWFkLiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlICovXG5leHBvcnQgY29uc3QgTWVudUJ1dHRvbiA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTEJ1dHRvbkVsZW1lbnQsIE1lbnVCdXR0b25Qcm9wcz4oXG4gICh7IGNoaWxkcmVuLCB0cmFpbGluZ0ljb246IFRyYWlsaW5nSWNvbiwgLi4ucm9vdFByb3BzIH0sIHJlZikgPT4ge1xuICAgIGNvbnN0IGNsYXNzZXMgPSB1c2VTdHlsZXMoe30pO1xuICAgIHJldHVybiAoXG4gICAgICA8QnV0dG9uIHJlZj17cmVmfSB7Li4ucm9vdFByb3BzfT5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgICB7ISFUcmFpbGluZ0ljb24gJiYgKFxuICAgICAgICAgIDxUcmFpbGluZ0ljb25cbiAgICAgICAgICAgIHJvbGU9XCJpbWdcIlxuICAgICAgICAgICAgYXJpYS1oaWRkZW5cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlcy50cmFpbGluZ0ljb259XG4gICAgICAgICAgLz5cbiAgICAgICAgKX1cbiAgICAgIDwvQnV0dG9uPlxuICAgICk7XG4gIH1cbik7XG4iXX0=